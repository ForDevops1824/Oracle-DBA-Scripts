\\10.146.64.137\infra_sop\HPE-ORACLE\Daily Checklist
D:\data backup 24.02.2022\backup\Backup_10022022\Praveen\New_14102022
=========================================================================================================
Queries For Production Database Monitoring:
----------------------------------------
SELECT a.INST_ID,a.INSTANCE_NAME,b.NAME,b.DB_UNIQUE_NAME,b.OPEN_MODE,b.DATABASE_ROLE,b.LOG_MODE,STATUS,DATABASE_STATUS,to_char(startup_time,'DD-MON-yyyy hh24:mi:ss') as startup_time,
sys_context('USERENV', 'INSTANCE_NAME') "I'm logged in" FROM  GV$INSTANCE a,GV$DATABASE b where a.INST_ID=b.INST_ID;

select name, state, round(total_mb/1024,2) TOTALGB,round(free_mb/1024,2)FREEGB,round(cold_used_mb/1024,2)USEDGB,round(100 * (cold_used_mb / total_mb)) " Pct. Used" from v$asm_diskgroup;

select  fs.tablespace_name "Tablespace", df.totalspace  "Total GB", (df.totalspace - fs.freespace)
"Used GB",  fs.freespace  "Free GB",  round(100 * (fs.freespace / df.totalspace)) "Pct. Used"from  
(select  tablespace_name, round(sum(bytes) / 1073741824,2) TotalSpace from
dba_data_files group by tablespace_name   ) df, 
(select  tablespace_name, round(sum(bytes) / 1073741824,2) FreeSpace  from  
dba_free_space group by  tablespace_name   ) fs where  df.tablespace_name = fs.tablespace_name;

select session_key,
		input_type,
		status,
		to_char(start_time,'yyyy-mm-dd hh24:mi:ss') start_time,
		to_char(end_time,'yyyy-mm-dd hh24:mi:ss') end_time,
		output_bytes_display,
		time_taken_display
from v$rman_backup_job_details where start_time>sysdate-14 and input_type like'%DB%' order by session_key desc;

select inst_id,sid,serial#, username,sql_id, osuser,substr(program||module,1,15) program, machine,event,
to_char(logon_time,'ddMon hh24:mi') login,last_call_et/60/60 "last call",status,type from
gv$session where last_call_et/60/60 > 1 and username not in 'SYS' and status='ACTIVE' and type<>'BACKGROUND' order by 7;

SELECT inst_id,dest_id,DESTINATION, STATUS, ARCHIVED_THREAD#, ARCHIVED_SEQ#,SYNCHRONIZATION_STATUS,SYNCHRONIZED, ERROR
FROM GV$ARCHIVE_DEST_STATUS
WHERE STATUS <> 'DEFERRED' AND STATUS <> 'INACTIVE'
order by INST_ID,DEST_ID;

--ALTER SYSTEM SET log_archive_dest_state_2='defer' SCOPE=BOTH SID='*';
--ALTER SYSTEM SET log_archive_dest_state_2='enable' SCOPE=BOTH SID='*';
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
Query For DR DATABASE Monitoring
---------------------------------------------

SELECT A.INST_ID,A.INSTANCE_NAME,B.NAME,STATUS,DATABASE_STATUS,b.database_role,B.OPEN_MODE ,TO_CHAR(STARTUP_TIME,'DD-MON-YYYY HH24:MI:SS') AS STARTUP_TIME 
FROM GV$INSTANCE A, GV$DATABASE B WHERE A.INST_ID=B.INST_ID;

select name, state, round(total_mb/1024,2) TOTALGB,round(free_mb/1024,2)FREEGB,round(cold_used_mb/1024,2)USEDGB, round(100 * (cold_used_mb / total_mb)) " Pct. Used" from v$asm_diskgroup;
select to_char(current_scn) , SCN_TO_TIMESTAMP(current_scn) from v$database;
select a.thread#, applied, notappld, notappld-applied delta from
(select thread#, max(sequence#) applied  from gv$archived_log where applied='YES' and resetlogs_change#=(select resetlogs_change#
from  v$database)
group by thread#) A,(select thread#, max(sequence#) notappld
from gv$archived_log where resetlogs_change#=(select resetlogs_change# from  v$database) group by thread#) B
where a.thread# = b.thread#;

SELECT inst_id,PROCESS, GROUP#, THREAD#, SEQUENCE#,STATUS, BLOCK#, BLOCKS from gv$managed_standby where THREAD#!=0 and process in ('RFS','LNS','MRP0')
order by thread#;

select session_key,
		input_type,
		status,
		to_char(start_time,'yyyy-mm-dd hh24:mi:ss') start_time,
		to_char(end_time,'yyyy-mm-dd hh24:mi:ss') end_time,
		output_bytes_display,
		time_taken_display
from v$rman_backup_job_details where start_time>sysdate-14 and input_type like'%DB%' order by session_key desc;


For Report :
-----------------------------------
--SESSION DETAILS REPORT :-
select c.username, c.active, c.inactive,c.killed, c.total, 2*TO_NUMBER(d.limit) LIMIT, 2*TO_NUMBER(d.limit)-c.total Available  from (
select username,
sum (case status when 'ACTIVE' then 1 else 0 end ) as active,
sum (case status when 'INACTIVE' then 1 else 0 end ) as inactive,
sum (case status when 'KILLED' then 1 else 0 end ) as killed,
count(status) as Total from gv$session group by username
order by killed desc) c,
(select a.username, b.limit from (select username, profile from dba_users) a, (select profile, limit from dba_profiles where resource_name='SESSIONS_PER_USER' and limit not in ('UNLIMITED', 'DEFAULT')) b where a.profile=b.profile) d
where d.username=c.username order by  Available ASC ;

--CONSOLIDATED REPORT :-
select INST_ID,
sum (case status when 'ACTIVE' then 1 else 0 end ) as active,
sum (case status when 'INACTIVE' then 1 else 0 end ) as inactive,
sum (case status when 'KILLED' then 1 else 0 end ) as killed,
count(status) as Total, 
to_char(current_timestamp,'DD-MON-YYYY HH24:MI:SS') AS COLLECTED_TIME from gv$session group by INST_ID;

select sum(bytes)/1024/1024/1024/1024 Size_in_TB from dba_segments;

	SELECT sn.INSTANCE_NUMBER,
			 sga.allo sga,
			 pga.allo pga,
			 (sga.allo + pga.allo) tot,
			 TRUNC (SN.END_INTERVAL_TIME, 'mi') time
		FROM (  SELECT snap_id,
					   INSTANCE_NUMBER,
					   ROUND (SUM (bytes) / 1024 / 1024 / 1024, 3) allo
				  FROM DBA_HIST_SGASTAT
			  GROUP BY snap_id, INSTANCE_NUMBER) sga,
			 (  SELECT snap_id,
					   INSTANCE_NUMBER,
					   ROUND (SUM (VALUE) / 1024 / 1024 / 1024, 3) allo
				  FROM DBA_HIST_PGASTAT
				 WHERE name = 'total PGA allocated'
			  GROUP BY snap_id, INSTANCE_NUMBER) pga,
			 dba_hist_snapshot sn
	   WHERE     sn.snap_id = sga.snap_id
			 AND sn.INSTANCE_NUMBER = sga.INSTANCE_NUMBER
			 AND sn.snap_id = pga.snap_id
			 AND sn.INSTANCE_NUMBER = pga.INSTANCE_NUMBER
	ORDER BY sn.snap_id DESC, sn.INSTANCE_NUMBER;

---KILLING SESSION REPORT  :-
select schemaname,status,machine,program,osuser,to_char(PREV_EXEC_START, 'DD-MON-YYYY HH24:MI') as LAST_SQL_EXEC_DATE, count(*), to_char(sysdate ,'DD-MON-YYYY HH24:MI')as SYS_TIME from gv$session 
where status in ('INACTIVE','KILLED') and PREV_EXEC_START < sysdate-2 and type = 'USER' and schemaname <> 'SYS' and event = 'SQL*Net message from client'
group by schemaname,status,machine,program,osuser,to_char(PREV_EXEC_START, 'DD-MON-YYYY HH24:MI') order by 6 desc, 1,3;

select 'alter system kill session ' ||''''||SID||','||SERIAL#||',@'||inst_id||''''||' immediate ;' from gv$session 
where status in ('INACTIVE','KILLED') and PREV_EXEC_START < sysdate-2 and type = 'USER' and schemaname <> 'SYS' and event = 'SQL*Net message from client'
order by inst_id;

---3 HRS SESSION REPORT :-
select schemaname, status,count(status) TOTAL_COUNT, to_char(current_timestamp,'DD-MON-YYYY HH24:MI:SS') AS COLLECTED_TIME from gv$session group by schemaname, status order by 1,2;
select inst_id, schemaname, status,machine,program, osuser, count(STATUS),TO_CHAR(logon_time,'DD-MON-YYYY HH24:MI:SS') AS LOGON_TIME,
TO_CHAR(current_timestamp,'DD-MON-YYYY HH24:MI:SS') AS COLLECTED_TIME from gv$session group by inst_id, schemaname, status, machine, program, osuser,logon_time order by 8;
select event,count(*),to_char(current_timestamp,'DD-MON-YYYY HH24:MI:SS') AS COLLECTED_TIME from gv$session group by event order by 2 desc;
select sql_id,machine, schemaname, count(*), TO_CHAR(current_timestamp,'DD-MON-YYYY HH24:MI:SS') AS COLLECTED_TIME from gv$session where sql_id is not null group by sql_id ,
sql_id,machine, schemaname order by 4 desc;
select sql_id,sql_fulltext from gv$sql where sql_id in (select sql_id from gv$session where sql_id is not null group by sql_id );

======================================================================================
-------------before killed the session take details of below query----------
select  PREV_SQL_ID, count(*) from gv$session where username='ACCIDENTREPORTING' group by prev_sql_id;

select PREV_sql_id,machine, schemaname, count(*), TO_CHAR(current_timestamp,'DD-MON-YYYY HH24:MI:SS') AS COLLECTED_TIME from gv$session where PREV_sql_id is not null  AND USERNAME = 'ACCIDENTREPORTING' group by PREV_sql_id ,
sql_id,machine, schemaname order by 4 desc;

select PREV_sql_id,sql_fulltext from gv$sql where PREV_sql_id in ( );

=======================================================================================================================
select 'alter system kill session ' ||''''||SID||','||SERIAL#||',@'||inst_id||''''||' immediate ;' from gv$session where username='INDSOFTX1PROD' and status in ('INACTIVE','KILLED') order by inst_id;
select 'alter system kill session ' ||''''||SID||','||SERIAL#||',@'||inst_id||''''||' immediate ;' from gv$session where username='DBA1' and MACHINE='MKHO2LISDBA0123' AND status in ('INACTIVE','KILLED') order by inst_id;

select 'alter system kill session'''||sid||','||serial#||',@'||inst_id||''' immediate;' from gv$session where USERNAME='PFMS_PROD' and STATUS='KILLED';
select 'alter system kill session'''||sid||','||serial#||',@'||inst_id||''' immediate;' from gv$session where USERNAME='IS_MYWORKSPACE' and STATUS='INACTIVE';

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
TABLESPACE details
======================================================
TAMP TABLESPACE SIZE BY GB
----------------------------------
SELECT *
FROM
  (SELECT a.tablespace_name,
    SUM(a.bytes/1024/1024/1024) allocated_gb
  FROM dba_temp_files a
  WHERE a.tablespace_name = 'TEMP'
  GROUP BY a.tablespace_name
  ) x,
  (SELECT SUM(b.bytes_used/1024/1024/1024) used_gb,
    SUM(b.bytes_free      /1024/1024/1024) free_gb
  FROM v$temp_space_header b
  WHERE b.tablespace_name = 'TEMP'
  GROUP BY b.tablespace_name
  );
  
TAMP TABLESPACE SIZE BY MB  
-------------------------------------
select a.tablespace_name tablespace,
d.TEMP_TOTAL_MB,
sum (a.used_blocks * d.block_size) / 1024 / 1024 TEMP_USED_MB,
d.TEMP_TOTAL_MB - sum (a.used_blocks * d.block_size) / 1024 / 1024 TEMP_FREE_MB
from v$sort_segment a,
(
select b.name, c.block_size, sum (c.bytes) / 1024 / 1024 TEMP_TOTAL_MB
from v$tablespace b, v$tempfile c
where b.ts#= c.ts#
group by b.name, c.block_size
) d
where a.tablespace_name = d.name
group by a.tablespace_name, d.TEMP_TOTAL_MB;



ORA-1652: unable to extend temp segment by 128 in tablespace TEMP
Tue Dec 23 07:51:11 2015
ORA-1652: unable to extend temp segment by 128 in tablespace TEMP

You can check for held TEMP segments with this query:

select
   srt.tablespace,
   srt.segfile#,
   srt.segblk#,
   srt.blocks,
   a.sid,
   a.serial#,
   a.username,
   a.osuser,
   a.status
from
   v$session    a,
   v$sort_usage srt
where
   a.saddr = srt.session_addr
order by
   srt.tablespace, srt.segfile#, srt.segblk#,
   srt.blocks;

UNUSED tablespace details:-
==============================================================================================================
select a.tablespace_name , A.Allocated , B.Freespace , round(b.freespace/a.allocated*100) "% Free"
from
(select tablespace_name ,sum(bytes)/1024/1024 Allocated from dba_data_files group by tablespace_name) A ,
(select tablespace_name,sum(bytes)/1024/1024 Freespace
from dba_free_space group by tablespace_name) B
where a.tablespace_name=b.tablespace_name and
a.tablespace_name not in (select distinct tablespace_name from dba_extents)
and
a.tablespace_name not in (select distinct tablespace_name from dba_segments)
and
a.tablespace_name not in (select distinct default_tablespace from dba_users);

alter database datafile '+DATA_DG03/mktretaildb/datafile/othertblspace.578.1064844147' RESIZE 10M;

alter table <tablename>  shrink space compact;

CREATE TABLESPACE AND ADD DATAFILE 
----------------------------------------------------
select  fs.tablespace_name "Tablespace", df.totalspace  "Total GB", (df.totalspace - fs.freespace)
"Used GB",  fs.freespace  "Free GB",  round(100 * (fs.freespace / df.totalspace)) "Pct. Used"from  
(select  tablespace_name, round(sum(bytes) / 1073741824,2) TotalSpace from
dba_data_files group by tablespace_name   ) df, 
(select  tablespace_name, round(sum(bytes) / 1073741824,2) FreeSpace  from  
dba_free_space group by  tablespace_name   ) fs where  df.tablespace_name = fs.tablespace_name;


select to_char(CREATION_TIME,'DD-MM-RRRR HH24:SS'),name from v$datafile ORDER BY CREATION_TIME desc;
select to_char(CREATION_TIME,'DD-MON-RRRR HH24:MI:SS') AS CREATED_TIME ,name,bytes/1024/1024/1024 as "Size in GB" from v$datafile ORDER BY CREATION_TIME desc;
select tablespace_name,file_name,bytes/1024/1024/1024 from dba_data_files where tablespace_name='&TABLESPACENAME';
select name, state, round(total_mb/1024,2) TOTALGB,round(free_mb/1024,2)FREEGB,round(cold_used_mb/1024,2)USEDGB from v$asm_diskgroup;

CREATE TABLESPACE TABLESPACE_NAME DATAFILE '+DATA_DG' SIZE 30G EXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO;
ALTER TABLESPACE TABLESPACE_NAME ADD Datafile '+DATA_DG' SIZE 30G AUTOEXTEND ON NEXT 1G MAXSIZE 31G;
ALTER TABLESPACE TABLESPACE_NAME ADD Datafile '+DATA_DG' SIZE 31G AUTOEXTEND OFF;

TO KNOW THE TABLEPSACE AUTOEXTEND STATUS
===================================================================================================================
select tablespace_name, file_name ,AUTOEXTENSIBLE,MAXBYTES,INCREMENT_BY from dba_data_files order by 1,2;

SELECT PROPERTY_NAME, PROPERTY_VALUE
FROM DATABASE_PROPERTIES
WHERE PROPERTY_NAME IN ('DEFAULT_PERMANENT_TABLESPACE','DEFAULT_TEMP_TABLESPACE');   
   
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
DATABASE GROWTH REPORT
======================================================
SELECT TABLESPACE_NAME, current_date,
round(((THIS_MONTH_SPACE - LAST_MONTH_SPACE)/1024),2) THIS_MONTH_GROWTH_IN_GB,
round(((LAST_MONTH_SPACE - SECOND_LAST_MONTH_SPACE)/1024),2) LAST_MONTH_GROWTH_IN_GB,
round(((SECOND_LAST_MONTH_SPACE-THIRD_LAST_MONTH_SPACE)/1024),2) SECOND_LAST_MONTH_GROWTH_IN_GB
FROM (
select
THIS_MONTH.TABLESPACE_NAME,
THIS_MONTH.USED_SPACE_IN_MB THIS_MONTH_SPACE,
LAST_MONTH.USED_SPACE_IN_MB LAST_MONTH_SPACE,
SECOND_LAST_MONTH.USED_SPACE_IN_MB SECOND_LAST_MONTH_SPACE,
THIRD_LAST_MONTH.USED_SPACE_IN_MB THIRD_LAST_MONTH_SPACE
from DB_REPORTS.ts_size_report  THIS_MONTH, DB_REPORTS.ts_size_report LAST_MONTH,
DB_REPORTS.ts_size_report SECOND_LAST_MONTH, DB_REPORTS.ts_size_report THIRD_LAST_MONTH
WHERE to_char(THIS_MONTH.timestamp,'YYYYMMDD') = TO_CHAR(SYSDATE,'YYYYMM')||'01'
AND to_char(LAST_MONTH.timestamp,'YYYYMMDD') = TO_CHAR(ADD_MONTHS(SYSDATE,-1),'YYYYMM')||'01' 
AND to_char(SECOND_LAST_MONTH.timestamp,'YYYYMMDD') = TO_CHAR(ADD_MONTHS(SYSDATE,-2),'YYYYMM')||'01' 
AND to_char(THIRD_LAST_MONTH.timestamp,'YYYYMMDD') = TO_CHAR(ADD_MONTHS(SYSDATE,-3),'YYYYMM')||'01' 
AND THIS_MONTH.TABLESPACE_NAME = LAST_MONTH.TABLESPACE_NAME AND LAST_MONTH.TABLESPACE_NAME = SECOND_LAST_MONTH.TABLESPACE_NAME
AND SECOND_LAST_MONTH.TABLESPACE_NAME = THIRD_LAST_MONTH.TABLESPACE_NAME) where tablespace_name not like '%UNDO%' order by 1;

select b.tablespace_name, tbs_size SizeGB,(tbs_size-a.free_space) as UsedGB, a.free_space FreeGB, current_date from
    (select tablespace_name, round(sum(bytes)/1024/1024/1024,2) as free_space
    from dba_free_space group by tablespace_name UNION
    select tablespace_name, round((free_space)/1024/1024/1024,2) as free_space from dba_temp_free_space) a,
    (select tablespace_name, round(sum(bytes)/1024/1024/1024, 2) as tbs_size
    from dba_data_files group by tablespace_name  ) b where a.tablespace_name not like '%UNDO%' and a.tablespace_name(+)=b.tablespace_name order by 1;
    
select name, state, round(total_mb/1024,2) TOTALGB,round(free_mb/1024,2)FREEGB,round(cold_used_mb/1024,2)USEDGB from v$asm_diskgroup order by 1;

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
REDO GENERATED DETAILS
============================================
select
  to_char(first_time,'YYYY-MM-DD') day,
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'00',1,0)),'999') "00",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'01',1,0)),'999') "01",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'02',1,0)),'999') "02",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'03',1,0)),'999') "03",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'04',1,0)),'999') "04",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'05',1,0)),'999') "05",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'06',1,0)),'999') "06",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'07',1,0)),'999') "07",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'08',1,0)),'999') "08",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'09',1,0)),'999') "09",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'10',1,0)),'999') "10",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'11',1,0)),'999') "11",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'12',1,0)),'999') "12",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'13',1,0)),'999') "13",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'14',1,0)),'999') "14",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'15',1,0)),'999') "15",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'16',1,0)),'999') "16",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'17',1,0)),'999') "17",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'18',1,0)),'999') "18",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'19',1,0)),'999') "19",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'20',1,0)),'999') "20",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'21',1,0)),'999') "21",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'22',1,0)),'999') "22",
  to_char(sum(decode(substr(to_char(first_time,'HH24'),1,2),'23',1,0)),'999') "23",
  COUNT(*) Total
from gv$log_history
group by to_char(first_time,'YYYY-MM-DD')
order by day desc;

SELECT A.*,
Round(A.Count#*B.AVG#/1024/1024/1024) Daily_Avg_GB
FROM
(
SELECT
To_Char(First_Time,'YYYY-MM-DD') DAY,
Count(1) Count#
FROM
gv$log_history
GROUP
BY To_Char(First_Time,'YYYY-MM-DD')
ORDER
BY 1 DESC
) A,
(
SELECT
Avg(BYTES) AVG#,
Count(1) Count#
FROM
gv$log
) B;

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
show parameter log_archive_dest_state
select * from v$archive_dest;
select name,log_mode,open_mode from v$database;

SELECT inst_id,dest_id,DESTINATION, STATUS, ARCHIVED_THREAD#, ARCHIVED_SEQ#,SYNCHRONIZATION_STATUS,SYNCHRONIZED, ERROR
FROM GV$ARCHIVE_DEST_STATUS
WHERE STATUS <> 'DEFERRED' AND STATUS <> 'INACTIVE'
order by INST_ID,DEST_ID;

--ALTER SYSTEM SET log_archive_dest_state_2='defer' SCOPE=BOTH SID='*';
--ALTER SYSTEM SET log_archive_dest_state_2='enable' SCOPE=BOTH SID='*';


weekly long running query
==================================================================================
with stats as (select round(sum(elapsed_time_delta)/1000000/decode(sum(executions_delta),0,1,
                      sum(executions_delta)),2) secs_per_exec,
                      sum(executions_delta) executions, sql_id, parsing_schema_name
               from dba_hist_sqlstat where snap_id > (select min(snap_id) from DBA_HIST_SNAPSHOT where trunc(begin_interval_time)= trunc(sysdate-6) ) group by sql_id,parsing_schema_name )
select parsing_schema_name,secs_per_exec, executions, stats.sql_id, sql_text
from stats, dba_hist_sqltext st
where stats.sql_id = st.sql_id and secs_per_exec > 600 and parsing_schema_name not in ('SYS')
order by 2 desc;



Long running query
---------------------------------------
select inst_id,sid,serial#, username,sql_id, osuser,substr(program||module,1,15) program, machine,event,
to_char(logon_time,'ddMon hh24:mi') login,last_call_et/60/60 "last call",status,type from
gv$session where last_call_et/60/60 > 1 and username not in 'SYS' and status='ACTIVE' and type<>'BACKGROUND' order by 7;

select sql_id,sql_fulltext from gv$sql where sql_id like ('dm6f2cqx9u4yy');
select sql_id,sql_fulltext from gv$sql where sql_id in ('dm6f2cqx9u4yy','','');

Below are various way to find out sql plan using SQL_ID

sqlplan
------------
set lines 2000
set pagesize 2000

Explain plan for a sql_id from cursor:-
SELECT * FROM table(DBMS_XPLAN.DISPLAY_CURSOR('&sql_id'));

Explain plan of a sql_id from AWR:
SELECT * FROM table(DBMS_XPLAN.DISPLAY_AWR('&sql_id'));


---From SQL plan:
select operation,options,object_name,cost from gv$sql_plan where sql_id='&sql_id';

select a.sid,a.serial#,b.spid,a.status,a.sql_id,a.program,a.prev_sql_id from gv$session a,gv$process b where a.paddr=b.addr and spid='&spid';
select a.INST_ID,a.sid,a.serial#,b.spid,a.status,a.sql_id,a.program,a.prev_sql_id from gv$session a,gv$process b where a.paddr=b.addr and spid='&spid';
select a.sid,a.serial#,b.spid,a.status,a.sql_id,a.program,a.prev_sql_id from gv$session a,gv$process b where a.paddr=b.addr and sql_id='&sql_id';

---From SQL plan(To find out the cost):
select SQL_ID, COST,OBJECT_OWNER,OBJECT_NAME,OBJECT_TYPE,CPU_COST,IO_COST,TIMESTAMP from dba_hist_sql_plan;

select a.sid,a.serial#,b.spid,a.status,a.sql_id,a.program,a.prev_sql_id,c.cost from gv$session a,gv$process b,gv$sql_plan c where a.paddr=b.addr 
and a.sql_id=c.sql_id and c.cost is not null order by c.cost desc;

SELECT SQL_ID, OPERATION, OPTIONS, OBJECT_NAME, OBJECT_TYPE, CARDINALITY, LAST_OUTPUT_ROWS
FROM GV$SQL_PLAN_STATISTICS_ALL

SELECT OPERATION,OPTIONS,OBJECT_NAME,COST FROM GV$SQL_PLAN WHERE SQL_ID in ('48xb5b70vkbxc');


To know which machines have maximum number of connections:-
==============================================================================================================================================================================
select machine,sql_id, count(*) from gv$session where schemaname = 'RETAILDB' group by machine, sql_id order by 3 desc;


select * from gv$sql where sql_id = '76r9gz2znv3hu';


High Cost Query For Mention Time
--------------------------------------------------------------------------------
column program format A25
column machine format A10
column module format A25
column user_id format 9999999
column count format 99999
SELECT * FROM (
SELECT /*+ PARALLEL */
        count(*) AS count,
        a.user_id, a.program, a.module, a.machine, a.sql_id, c.cost
        ,ROW_NUMBER() OVER (PARTITION BY a.sql_id ORDER BY c.cost DESC) rank 
 FROM SYS.DBA_HIST_ACTIVE_SESS_HISTORY a, gv$sql_plan c
WHERE a.sample_time > TO_DATE('04-AUG-2022 10:00:00','DD-MON-YYYY HH24:MI:SS')
AND a.sample_time < TO_DATE('04-AUG-2022 18:00:00','DD-MON-YYYY HH24:MI:SS')
AND a.sql_id=c.sql_id
AND C.COST IS NOT NULL
GROUP BY a.user_id, a.program, a.module, a.machine, a.sql_id,  c.cost
ORDER BY a.sql_id,C.COST desc
)  where rank = 1 order by cost desc
/

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Database Physical Size :
========================

select ( select sum(bytes)/1024/1024/1024 data_size from dba_data_files ) +
( select nvl(sum(bytes),0)/1024/1024/1024 temp_size from dba_temp_files ) +
( select sum(bytes)/1024/1024/1024 redo_size from sys.v_$log ) +
( select sum(BLOCK_SIZE*FILE_SIZE_BLKS)/1024/1024/1024 controlfile_size from v$controlfile) “Size in GB” from dual;

Database Logical Size :
=======================
select sum(bytes)/1024/1024/1024  "Size in GB" from dba_segments;

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
INVALID OBJECTS COMPILE 
==========================
find invalid object :
------------------------
set pagesize 9999
set lines 9999
col OWNER for a20
col OBJECT_NAME for a30
SELECT OWNER,OBJECT_NAME,OBJECT_TYPE,LAST_DDL_TIME,STATUS,TIMESTAMP FROM DBA_OBJECTS WHERE STATUS != 'VALID';
SELECT OWNER,OBJECT_NAME,OBJECT_TYPE,LAST_DDL_TIME,STATUS,TIMESTAMP FROM DBA_OBJECTS WHERE STATUS != 'VALID' ORDER BY OWNER;

SELECT OWNER,OBJECT_NAME,OBJECT_TYPE,LAST_DDL_TIME,STATUS,TIMESTAMP FROM DBA_OBJECTS 
WHERE STATUS != 'VALID'and OWNER NOT IN ('SYSTEM','SYS') ORDER BY OWNER;

SELECT OWNER,OBJECT_NAME,OBJECT_TYPE,LAST_DDL_TIME,STATUS,TIMESTAMP FROM DBA_OBJECTS WHERE STATUS != 'VALID'and 
OWNER NOT IN ('SYSTEM','SYS') and LAST_DDL_TIME <= sysdate - 90 ORDER BY OWNER;

first try to compile object:
---------------------------------
select  'alter ' ||
       decode(object_type, 'PACKAGE BODY', 'package', object_type) ||
       ' ' || owner || '.' ||
       object_name||
       ' compile' ||
       decode(object_type, 'PACKAGE BODY', ' body;', ';')
from   dba_objects
where  status = 'INVALID' and OWNER NOT IN ('SYSTEM','SYS') and LAST_DDL_TIME <= sysdate - 90 ORDER BY OWNER;

SQL>@?/rdbms/admin/utlrp

Session altered.
SQL>
Connected to:
Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production
Version 19.8.0.0.0

SQL> alter materialized view RETAILDB.MV_MOB_CO_CUSTDATA compile;

Materialized view altered.

SQL> alter SYNONYM RETAILDB_VIEW.MV_MOB_CO_CUSTDATA compile;

Synonym altered.

SQL>

Take backup of object DDL using below query sample :
-----------------------------------------------------------
set long 20000 longchunksize 20000 pagesize 0 linesize 1000 feedback off verify off trimspool on
column ddl format a1000

Merged Query:
----------------------------------
select  'SELECT DBMS_METADATA.GET_DDL( ' || '''' || decode(object_type, 'PACKAGE BODY', 'package', object_type) ||''''||
       ', ' ||'''' || object_name||''''|| ',' ||''''|| owner || ''''||
       ') FROM DUAL' ||
       decode(object_type, 'PACKAGE BODY', ' ;', ';')
from   dba_objects
where  status = 'INVALID' and LAST_DDL_TIME <= sysdate - 90 ORDER BY OWNER;


if object is still invalid after compile then you can use below query to drop object.
Make sure no Oracle internal object (e.g sys,system ect) in the list. and verify object before drop.

Drop object query :
---------------------------------------------------------
select  'drop ' ||
       decode(object_type, 'PACKAGE BODY', 'package', object_type) ||
       ' ' || owner || '.' ||
       object_name||
       ';'||
       decode(object_type, 'PACKAGE BODY', ' body;')
from   dba_objects
where  status = 'INVALID' and owner not IN ('SQLTXADMIN','SYS','SYSTEM') and LAST_DDL_TIME <= sysdate - 90 ORDER BY OWNER;



[oracle@retailora02 ~]$ w
17:05:48 up 348 days, 12:33,  7 users,  load average: 16.35, 36.33, 43.96
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
col current_scn for 99999999999999999999;

select current_scn from v$database;

select to_char(489517385) as SCN,SCN_TO_TIMESTAMP(489517385) as TIME from v$database;
select timestamp_to_scn(to_timestamp('28-10-2022 15:20:00','DD-MM-YYYY HH24:MI:SS')) as scn from dual;

select timestamp_to_scn(to_timestamp('28-10-2022 15:20:00','DD-MM-YYYY HH24:MI:SS')) as scn,to_char('28-10-2022 15:20:00') as TIME from dual;


SQL> select to_char(489517385) as SCN,SCN_TO_TIMESTAMP(489517385) as TIME from v$database;

SCN       TIME
--------- ---------------------------------------------------------------------------
489517385 28-OCT-22 03.20.00.000000000 PM

SQL>
SQL> col scn for 99999999999999999999;
SQL> select timestamp_to_scn(to_timestamp('28-10-2022 15:20:00','DD-MM-YYYY HH24:MI:SS')) as scn,to_char('28-10-2022 15:20:00') as TIME from dual;

                  SCN TIME
--------------------- -------------------
            489517385 28-10-2022 15:20:00

SQL>



col CORRUPTION_CHANGE# for 99999999999999999999;
select * from v$database_block_corruption;

select  filename, status from v$block_change_tracking;
Show parameter DB_CREATE_FILE_DEST;
alter system set DB_CREATE_FILE_DEST='+DATA_DG03' scope=both sid='*';
alter database enable block change tracking;


Mail check
------------------------
echo "Subject: hello from Rajesh" | sendmail mktisdba@indianoil.in

==================================================================================
AHFCTL UTILITE
===========================
Auto Collection Using TFA

1)       Download and install the latest version of TFA using the AHF installer: Download AHF here.

          (a) Note: To check whether it is installed or not, run Run grep TFA_HOME = /etc/init.d/init.tfa
          (b) Note: To check the current version, run tfactl version -all
          (c) Note: To check the status of TFA, run tfactl print status
		  
		  
For Version
-------------------
$TFA_HOME/bin/ahfctl statusahf
tfactl print repository

oracle-tfa.service - Oracle Trace File Analyzer
-----------------------------------------------------
$TFA_HOME/bin/systemctl status oracle-tfa.service

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
ARCH DG SPACE RELEASE Query
============================================================
DELETE ARCHIVELOG ALL COMPLETED BEFORE 'sysdate-3';
DELETE NOPROMPT ARCHIVELOG UNTIL TIME 'SYSDATE-2';
DELETE FORCE ARCHIVELOG ALL COMPLETED BEFORE 'sysdate-3';
DELETE NOPROMPT FORCE ARCHIVELOG ALL COMPLETED BEFORE 'sysdate-2';
delete archivelog all backed up 1 times to SBT_TAPE;

AWR Report (Automatic Workload Report Repository)
===============================
SQL> select snap_id, begin_interval_time from sys.dba_hist_snapshot order by snap_id;
SQL> @?/rdbms/admin/awrrpt.sql === Non RAC
SQL> @?/rdbms/admin/awrgrpt.sql === RAC
SQL> @?/rdbms/admin/awrgrpti.sql === Instance level in RAC
SQL> @?/rdbms/admin/awrddrpt.sql === to compare 2 Awr reports

ADDM Report: (Automatic Database Diagnostic Monitoring)

SQL> @?/rdbms/admin/addmgrpt.sql

NOHUP COMMAND / script running in background
======================
$ nohup rman target / cmdfile=backup.rcv log=backup_23092022.log &		// For RMAN
$ nohup sqlplus username/password @script.sql > file.out 2>&1 & 		// For Sql
$ nohup sqlplus "/ as sysdba" @script.sql > script.log 2>&1 &				// For Sql
$ nohup ./text.sh > log.txt &										// For linux
$ nohup scp oracle@10.146.66.104:/backup_location/backup/file.txt > nohup.log 2>&1 &
[oracle@mudcporaind01 18102022]$ nohup rsync -av /backup_new/disk_backup/18102022 oracle@10.146.66.104:/backup/test --progress  > /tmp/transfer.log &
[1] 242604
[oracle@mudcporaind01 18102022]$ nohup: ignoring input and redirecting stderr to stdout


[1]+  Stopped                 nohup rsync -av /backup_new/disk_backup/18102022 oracle@10.146.66.104:/backup/test --progress > /tmp/transfer.log
[oracle@mudcporaind01 18102022]$
[oracle@mudcporaind01 18102022]$
[oracle@mudcporaind01 18102022]$ tail -100f /tmp/transfer.log


^C
[oracle@mudcporaind01 18102022]$ jobs
[1]+  Stopped                 nohup rsync -av /backup_new/disk_backup/18102022 oracle@10.146.66.104:/backup/test --progress > /tmp/transfer.log
[oracle@mudcporaind01 18102022]$
[oracle@mudcporaind01 18102022]$
[oracle@mudcporaind01 18102022]$ fg 1
nohup rsync -av /backup_new/disk_backup/18102022 oracle@10.146.66.104:/backup/test --progress > /tmp/transfer.log
Password:
[oracle@mudcporaind01 18102022]$


datapump export /import run in background
=============================================================
Step 1: Create export or import parameter file
--------------------------------------------------
$ vi exp.par

userid=system/tiger
directory=DATAPUMP
DUMPFILE=export_REMS_02082022.dmp
LOGFILE=export_REMS_02082022.log
schemas=REMS
exclude=table:"IN('REMS_REF_SAP_CONNECTION')" CONTENT=ALL;


Step 2: Create a shell script which calls the expdp in nohup and change the permission to executable.
-------------------------------------------------
$ vi export.sh

nohup expdp parfile=/home/oracle/st/exp.par &

 
$ chmod 744 export.sh


Step 3: run the shell script in nohup. This will release the prompt immediately and there will not be any running job in the prompt. You can see the datapump job running in DBA_DATAPUMP_JOBS view.
-------------------------------------------------
$ nohup export.sh &


release / mount point space
----------------------
df -h
du -Sh /backup | sort -rh | head -5
-------------------------------------------

cd /nsr/apps/logs
find libnsrora* -mtime +3 -exec ls -ltr {} \;
find  libnsrora* -mtime +3 -exec rm {} \;

release /database mountpoint space
-----------------------------------
cd /database/archive
find *.dbf -mtime +7 -exec ls -ltr {} \;
find *.dbf -mtime +4 -exec rm {} \;


MRP PROCESS CHECK:
===================
set lines 200	 
SELECT inst_id,PROCESS, GROUP#, THREAD#, SEQUENCE#,STATUS, BLOCK#, BLOCKS from gv$managed_standby where THREAD#!=0 and process in ('RFS','LNS','MRP0')order by thread#;

MRP APPLIED STATYS CHECK:
==================
select thread#,max(sequence#) from v$archived_log where applied='YES' group by thread#; 

SELECT THREAD#, SEQUENCE#, APPLIED FROM GV$ARCHIVED_LOG where applied= 'YES' order by SEQUENCE#;
select DEST_ID,THREAD#,SEQUENCE#,FIRST_TIME from GV$ARCHIVED_LOG where THREAD#=2 order by SEQUENCE#;

alter session set nls_date_format = 'DD-MON-YYYY HH24:MI:SS';
select DEST_ID,THREAD#,SEQUENCE#,FIRST_TIME, applied from gv$ARCHIVED_LOG where THREAD#=1 order by SEQUENCE# desc;

copy file diskgroup to filesystem and filesystem to diskgroup
=================================================================
cp irasorarackdb_1_46647_1082429888.arc /tmp
cp /tmp/irasorarackdb_1_46647_1082429888.arc +ARCH_DG/arch/

alter database register logfile '/tmp/irasorarackdb_1_46647_1082429888.arc';

MRP STOP/START:
===============
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL;  (MRP Cancel)
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT FROM SESSION;  
alter database recover managed standby database using current logfile disconnect from session;

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
USER CREATION AND EXPORT AND IMPORT QUERIES
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
========================================
ALL SCHEMAS SIZE AND OBJECTS SIZE
========================================
SELECT OWNER,round((SUM(BYTES/1024/1024/1024)),2) AS SCHEMA_SIZE_GB FROM DBA_SEGMENTS group by owner order by 2 desc;

select owner, segment_name, segment_type, gb from 
(select owner, segment_name, segment_type, bytes / 1024 / 1024 / 1024 "GB" from dba_segments order by bytes desc)
where owner in ('ROPHASE6','TT_CREW');

select owner, segment_name, segment_type, Gb from (
select owner, segment_name, segment_type, bytes / 1024 / 1024/1024 "GB" from dba_segments order by bytes desc)
where rownum < 11;

table count check:
=================
select count(*) from RAPH6_MON.KAFKA_DEN_PUSH_RES;
SQL> select count(*) from RAPH6_MON.KAFKA_DEN_PUSH_RES;

  COUNT(*)
----------
    305797

Index details :-
-------------------
select OWNER,INDEX_NAME,STATUS,TABLE_NAME from dba_indexes where TABLE_NAME='&TABLE_NAME';
select a.OWNER,a.TABLE_NAME,a.INDEX_NAME,a.tablespace_name,a.status,b.bytes/1024/1024/1024  from dba_indexes a,DBA_SEGMENTS b where a.INDEX_NAME=b.SEGMENT_NAME and TABLE_NAME='&TABLE_NAME';

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx	
User Managements (Create/alter user, grant/revoke grants)
==========================================================================================================================
CREATE USER USER_NAME IDENTIFIED BY PASSWORD DEFAULT TABLESPACE TABLESPACE01 PROFILE IOCL_SMALL_PROFILE;
GRANT UNLIMITED TABLESPACE TO USER_NAME;
GRANT CONNECT,RESOURCE TO USER_NAME;
GRANT CREATE TABLE, CREATE VIEW,CREATE SEQUENCE,CREATE PROCEDURE TO USER_NAME;

create user in PDB database
===================================
Create Common Users :
-------------------------------------
CONN / AS SYSDBA
-- Create the common user using the CONTAINER clause.
CREATE USER c##test_user1 IDENTIFIED BY password1 CONTAINER=ALL;
GRANT CREATE SESSION TO c##test_user1 CONTAINER=ALL;

-- Create the common user using the default CONTAINER setting.
CREATE USER c##test_user2 IDENTIFIED BY password1;
GRANT CREATE SESSION TO c##test_user2;

Create Local Users
===================================
CONN / AS SYSDBA

-- Switch container while connected to a common user.
ALTER SESSION SET CONTAINER = pdb1;

-- Create the local user using the CONTAINER clause.
CREATE USER test_user3 IDENTIFIED BY password1 CONTAINER=CURRENT;
GRANT CREATE SESSION TO test_user3 CONTAINER=CURRENT;

-- Connect to a privileged user in the PDB.
CONN system/password@pdb1

-- Create the local user using the default CONTAINER setting.
CREATE USER test_user4 IDENTIFIED BY password1;
GRANT CREATE SESSION TO test_user4;


Query to provide grants on tables of schema to user : 
--------------------------------------------------------
select 'grant select,insert,update,delete on QMS.'||table_name||' to QMS_USER;' from dba_tables where owner = 'QMS';
select 'grant select on COM_EMP_DB.'||table_name||' to 'CEM_FTP_USR;' from dba_tables where owner = 'COM_EMP_DB';
select owner,table_name from all_tables where table_name='&table_name';

To check the roles granted to a user:
SELECT *   FROM DBA_ROLE_PRIVS   WHERE GRANTEE = '&USERNAME';
Permissions already have:
SELECT *   FROM DBA_TAB_PRIVS   WHERE GRANTEE = '&USERNAME';
System privileges granted:
SELECT *   FROM DBA_SYS_PRIVS   WHERE GRANTEE = '&USERNAME';


grant CREATE JOB to user;

grant DEBUG CONNECT SESSION to INDAS ;
grant DEBUG ANY PROCEDURE to INDAS ;
grant execute on DBMS_DEBUG_JDWP to INDAS;

select 'alter user ' || username || ' account lock;' from dba_users where account_status='OPEN';

alter user USERNAME account lock;
alter user &USERNAME account lock;

alter user USERNAME account unlock;
alter user &username account unlock;

drop user USERNAME cascade;
drop user &USERNAME cascade;

alter user &username identified by &password;

------------------------------------------------------------
set long 20000 longchunksize 20000 pagesize 0 linesize 1000 feedback off verify off trimspool on
column ddl format a1000

SQL> select dbms_metadata.get_ddl('USER','WEBDOC') from dual;

DBMS_METADATA.GET_DDL('USER','WEBDOC')
--------------------------------------------------------------------------------

   CREATE USER "WEBDOC" IDENTIFIED BY VALUES '83F2C5AEA21F5758'
      DEFAULT T


SQL>
SQL>

alter user WEBDOC grant connect through DBA1;
alter user WEBDOC revoke connect through DBA1;
 
conn DBA1[WEBDOC]

gMAh2ZsWr5

ACL Grants
------------------------
select * from dba_network_acls;

begin
dbms_network_acl_admin.append_host_ace
(host=>'10.146.76.11',
ace=> sys.xs$ace_type(privilege_list=>sys.XS$NAME_LIST('JDWP') ,
principal_name=>'PFMS_PROD',
principal_type=>sys.XS_ACL.PTYPE_DB) );
end;
/

================================================================================================
The v$pwfile_users view contains a list of all users who have been granted the SYSDBA or SYSOPER privilege.
===================================================================================================================
select * from v$pwfile_users;

chown -R oracle:oinstall patch_19c
chmod -R 777 /db_monitor/patch_19c
chmod -R 755 SystemStatus.sh

==============================================
PROFILE CREATE AND ASSIGN
====================================

SQL> CREATE PROFILE "IOCL_USER_PROFILE"
		LIMIT
         COMPOSITE_LIMIT UNLIMITED
         SESSIONS_PER_USER 20
         CPU_PER_SESSION UNLIMITED
         CPU_PER_CALL UNLIMITED
         LOGICAL_READS_PER_SESSION UNLIMITED
         LOGICAL_READS_PER_CALL UNLIMITED
         IDLE_TIME 15
         CONNECT_TIME 120
         PRIVATE_SGA UNLIMITED
         FAILED_LOGIN_ATTEMPTS 10
         PASSWORD_LIFE_TIME UNLIMITED
         PASSWORD_REUSE_TIME UNLIMITED
         PASSWORD_REUSE_MAX UNLIMITED
         PASSWORD_VERIFY_FUNCTION NULL
         PASSWORD_LOCK_TIME 86400/86400
         PASSWORD_GRACE_TIME 604800/86400 ;

Profile created.

SQL> Alter user USERNAME profile IOCL_USER_PROFILE;

User altered.

SQL>

*SESSION_PER_USER – No. of allowed concurrent sessions for a user
*CPU_PER_SESSION – CPU time limit for a session, expressed in hundredth of seconds.
*CPU_PER_CALL – Specify the CPU time limit for a call (a parse, execute, or fetch), expressed in hundredths of seconds.
*CONNECT_TIME – Specify the total elapsed time limit for a session, expressed in minutes.
*IDLE_TIME – Specify the permitted periods of continuous inactive time during a session, expressed in minutes.
*LOGICAL_READS_PER_SESSION – Specify the permitted number of data blocks read in a session, including blocks read from memory and disk
*LOGICAL_READS_PER_CALL –permitted number of data blocks read for a call to process a SQL statement (a parse, execute, or fetch).
*PRIVATE_SGA – SGA a session can allocate in the shared pool of the system global area (SGA), expressed in bytes.
*FAILED_LOGIN_ATTEMPTS – No. of failed attempts to log in to the user account before the account is locked
*PASSWORD_LIFE_TIME: No. of days the account will be open. after that it will expiry.
*PASSWORD_REUSE_TIME: number of days before which a password cannot be reused
*PASSWORD_REUSE_MAX: number of days before which a password can be reused
*PASSWORD_LOCK_TIME: Number of days the user account remains locked after failed login
*PASSWORD_GRACE_TIME: Number of grace days for user to change password
*PASSWORD_VERIFY_FUNCTION: PL/SQL that can be used for password verification

Alter a profile:
-----------------------
ALTER PROFILE APP_PROFILE LIMIT FAILED_LOGIN_ATTEMPS UNLIMITED;
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
Datapump :
========================================================================
BEFORE CREATE USER PRE_CHECK
		SELECT * FROM DBA_USERS WHERE USERNAME=UPPER('USER_NAME');
		SELECT SUM(BYTES/1024/1024/1024) FROM DBA_SEGMENTS WHERE OWNER=UPPER('USER_NAME');
		SELECT COUNT(*) FROM DBA_OBJECTS WHERE OWNER=UPPER('USER_NAME');
		SELECT OWNER,COUNT(OBJECT_TYPE) "COUNT", OBJECT_TYPE
			FROM ALL_OBJECTS WHERE OWNER=UPPER('USER_NAME') GROUP BY OWNER,OBJECT_TYPE;
		SELECT SEGMENT_TYPE,COUNT(*),TABLESPACE_NAME FROM DBA_SEGMENTS WHERE OWNER=UPPER('USER_NAME') 
			GROUP BY SEGMENT_TYPE, TABLESPACE_NAME ORDER BY 3;
			

SELECT * FROM DBA_TABLES WHERE TABLE_NAME=UPPER('TPA_AUDIT_MAPPING_IMAGE');
SELECT SUM(BYTES/1024/1024/1024) FROM DBA_SEGMENTS WHERE SEGMENT_NAME=UPPER('TPA_AUDIT_MAPPING_IMAGE');
SELECT COUNT(*) FROM DBA_OBJECTS WHERE OBJECT_NAME=UPPER('TPA_AUDIT_MAPPING_IMAGE');
SELECT OWNER,COUNT(OBJECT_TYPE) "COUNT", OBJECT_TYPE
			FROM ALL_OBJECTS WHERE OBJECT_NAME=UPPER('TPA_AUDIT_MAPPING_IMAGE') GROUP BY OWNER,OBJECT_TYPE;
SELECT SEGMENT_TYPE,COUNT(*),TABLESPACE_NAME FROM DBA_SEGMENTS WHERE SEGMENT_NAME='TPA_AUDIT_MAPPING_IMAGE'
			GROUP BY SEGMENT_TYPE, TABLESPACE_NAME ORDER BY 3;


set lines 200 pages 300
col directory_name for a30
col directory_path for a80
col owner for a15
select owner,directory_name,directory_path from dba_directories order by 2;

IF DIRECTORY NOT EXITS :-
--------------------------------------------------
CREATE A DATAPUMP FOLDER IN SITE BACKUP OR ORALCE
		MKDIR DATAPUMP	(IN ORACLE PROMPT)
CONNECT TO SQL
		CREATE OR REPLACE DIRECTORY datapump AS '/backup_temp/datapump';
		GRANT READ,WRITE ON DIRECTORY datapump TO SYSTEM;	

DROP DIRECTORY DIRECTORY_NAME;

select * from dba_directories;

DROP DIRECTORY DATAPUMP;

CREATE OR REPLACE DIRECTORY datapump AS '/backup/datapump';
GRANT READ,WRITE ON DIRECTORY datapump TO SYSTEM;

EXPORT
-----------
BEFORE EXPORT PRE_CHECK:
	1.	FIND SIZE OF EXPORT FULL/SCHEMA/TABLE:
			EXPDP DIRECTORY=DATAPUMP CONTENT=ALL SCHEMAS=TT_CREW EXCLUDE=STATISTICS ESTIMATE_ONLY=YES;
	2.	CHECK AS PER EXPORT FILE SIZE SPACE AVALIABLE OR NOT IN MOUNT_POINT.
	3.	IF METADATA ONLY THEN USE PARAMETER [CONTENT=METADATA_ONLY]
		
FULL DATABASE :-
EXPDP DIRECTORY=DATAPUMP FULL=Y DUMPFILE=EXPORT_DATABASENAME_FULL_DATE.DMP LOGFILE=EXPORT_DATABASENAME_FULL_DATE.LOG PARALLEL=2;

FOR SCHEMA LEVEL :-
EXPDP DIRECTORY=DATAPUMP SCHEMAS=SCHEMA_NAME DUMPFILE=EXPORT_SCHEMANAME_DATE.DMP LOGFILE=EXPORT_SCHEMANAME_DATE.LOG CONTENT=ALL EXCLUDE=STATISTICS VERSION=11.2;

FOR TABLE LEVEL :-
EXPDP DIRECTORY=DATAPUMP TABLES=SCHEMA_NAME.TABLE_NAME DUMPFILE=EXPORT_NAME_DATE.DMP LOGFILE=EXPORT_NAME_DATE.LOG;

ONCE EXPORT COMPLETED THEN CHECK LOG FILES FOR COUNT OF TABLE,ROW AND ANY ERROR. 
//SCP EXPORT_FILENAME.DMP ORACLE@SERVERIP:LOCATION 
SCP EXPORT_SCHEMANAME_DATE.DMP ORACLE@10.146.66.18:/BACKUP


Exclude Parameter :
---------------------------
single table :-
expdp directory=DATAPUMP schemas=PFMS_PROD DUMPFILE=export_PFMS_PROD_25102022.dmp LOGFILE=export_PFMS_PROD_25102022.log exclude = table:"IN('MST_RFC_PARAMETERS')" CONTENT=ALL;

Multiple table (exclude):-
expdp directory=DATAPUMP schemas=PFMS_PROD DUMPFILE=export_PFMS_PROD_25102022.dmp LOGFILE=export_PFMS_PROD_25102022.log exclude = table:"IN('MST_RFC_PARAMETERS')" exclude = table:"IN('MST_SMS_API_DETAILS')" CONTENT=ALL;
expdp directory=DATAPUMP schemas=PFMS_PROD DUMPFILE=export_PFMS_PROD_test.dmp LOGFILE=export_PFMS_PROD_test.log exclude = table:"IN\('MST_RFC_PARAMETERS'\,'MST_SMS_API_DETAILS'\)" CONTENT=ALL;

expdp directory=datapump dumpfile=DHRUVA2_20102020.dmp logfile=DHRUVA2_20102020.log  tables=DHRUVA2.TPA_AUDIT_MAPPING_OBS,DHRUVA2.TPA_AUDIT_INDEX_WISE_SCORE,DHRUVA2.TPA_SEVA_PARAM_SCORE,DHRUVA2.TPA_FIT_CAT_SCORE content=all;


IMPORT
--------------------------
BEFORE IMPORT PRE_CHECK:
	1.	USER EXIST OR NOT. IF NOT THEN CREATE USER AS PER CLIENT PROVIDE
	2.  CHECK TABLESPACE SIZE. IF NOT AVALIABLE OR LESS AMOUNT OF SIZE AVALIABLE THEN ADD DATAFILE IN TABLESPACE (NEED APPORAVAL FROM CLIENT)
	3.  TABLESPACE DETAILS OF EXPORT SERVER. IF TABLESPACE IS NOT SAME OR MULTIPLE TABLESPACE EXIST THEN USE REMAP_TABLESPACE
	4.	EXPORT SCHEMA/TABLE SAME AS IMPORT SCHEMA/TABLE OR NOT. IF NOT THEN USE REMAP_SCHEMA/REMAP_TABLE 

REMAP_TABLESPACE=TABLESPACE_NAME_EXPORT:TABLESPACE_NAME_IMPORT
REMAP_SCHEMAS=SCHEMA_NAME_EXPORT:SCHEMA_NAME_IMPORT
REMAP_TABLE=SCHEMA_NAME.TABLE_NAME_EXPORT:SCHEMA_NAME.TABLE_NAME_IMPORT

IMPDP DIRECTORY=DATAPUMP SCHEMAS=SCHEMA_NAME DUMPFILE=EXPORT_SCHEMANAME_DATE.DMP LOGFILE=EXPORT_SCHEMANAME_DATE.LOG REMAP_TABLESPACE=INSPECTION_DATA:USERS TABLE_EXISTS_ACTION=REPLACE CONTENT=ALL EXCLUDE=STATISTICS;

impdp directory=datapump_bkp schemas=PFMS_REFHQ dumpfile=EXPORT_PFMS_REFHQ_28022022_PROD.dmp logfile=IMPORT_PFMS_REFHQ_28022022_PROD.log remap_tablespace=TABLESPACE01:IRAS_DEV_TS table_exists_action=replace content=all exclude=statistics TRANSFORM=oid:n;

AFTER COMPLETED ALL ACTIVITY OF EXPORT AND IMPORT CHECK TABLE AND ROW COUNT OF TABLE ARE SAME BOTH EXPORT SERVER AND IMPORT SERVER OR NOT.
		1. CHECK BOTH EXPORT AND IMPORT LOG FOR COUNT SAME OR NOT
		2. SELECT OWNER,OBJECT_TYPE, COUNT(*) "OBJECT_COUNT" FROM ALL_OBJECTS WHERE OWNER IN ('SCHEMANAME') GROUP BY OWNER, OBJECT_TYPE ORDER BY 1,2;
		3. SELECT OWNER,TABLE_NAME,NUM_ROWS FROM DBA_TABLES WHERE OWNER IN ('SCHEMANAME') ORDER BY 1,2;
		4. select owner,table_name,num_rows from dba_tables where table_name in ('ALL_ASSET','LOCATION','PO_DETAILS','ROLE_MASTER');
	exec dbms_stats.gather_schema_stats(ownname=>'AV_DOCS',estimate_percent=>100,degree=>4,cascade=>true,no_invalidate=>false);


SET lines 200
COL owner_name FORMAT a10;
COL job_name FORMAT a20
COL state FORMAT a12
COL operation LIKE state
COL job_mode LIKE state
COL owner.object for a50

SELECT owner_name, job_name, rtrim(operation) "OPERATION",
       rtrim(job_mode) "JOB_MODE", state, attached_sessions
  FROM dba_datapump_jobs
 WHERE job_name NOT LIKE 'BIN$%'
 ORDER BY 1,2;

To monitor executing jobs using dba_datapump_jobs view:
===============================================================
set linesize 200
set pagesize 200
col owner_name format a12
col job_name format a20
col operation format a12
col job_mode format a20
SELECT 
owner_name, 
job_name, 
operation, 
job_mode, 
state 
FROM 
dba_datapump_jobs
where 
state='EXECUTING';

To check the waiting status and wait event of the job waiting for:
======================================================================
SELECT   w.sid, w.event, w.seconds_in_wait
   FROM   gV$SESSION s, DBA_DATAPUMP_SESSIONS d, gV$SESSION_WAIT w
    WHERE   s.saddr = d.saddr AND s.sid = w.sid;

To monitor and perform various operations from the expdp/impdp prompt:
=============================================================================
[oracle@orahow ~]$ expdp attach=Job_name
expdp / as sysdba attach=job_name
export>status
export>stop_job
export>start_jop
export>kill_job

To get the detail information like SID, Serial#, and % of completion of backup:
===================================================== =======================
SELECT OPNAME, SID, SERIAL#, CONTEXT, SOFAR, TOTALWORK, ROUND(SOFAR/TOTALWORK*100,2) "%_COMPLETE"
FROM 
gV$SESSION_LONGOPS
WHERE 
OPNAME in
(select d.job_name from gv$session s, gv$process p, dba_datapump_sessions d where 
p.addr=s.paddr and s.saddr=d.saddr)
AND OPNAME NOT LIKE '%aggregate%' AND TOTALWORK != 0
AND SOFAR <> TOTALWORK;


select * from gv$session where module='Data Pump Worker';
select * from gv$datapump_job;
select * from gv$datapump_session;
select * from gv$session_longops;


New Substitution Variables for File Names
===============================================================
Multiple files are generated by parallel exports, so each file needs to have a unique name. This is achieved using substitution variables. 
In previous releases the only substitution variable available was "%U", which generated a two digit number from 01-99. Oracle 12.2 includes additional substitution variables.

The following substitution variables are only available for export operations.

%d, %D : The current day of the month in DD format.
%m, %M : The current month in MM format.
%y, %Y : The current year in YYYY format.
%t, %T : The current date in YYYYMMDD format.
The following substitution variables are available for both export and import operations.

%U : Unchanged from previous releases. A two digit number incremented between 01-99.
%l, %L : This starts off similar to "%U", producing a two digit number between 01-99, but it can extend up to 2147483646, so the resulting file name is not a fixed length.

==================================================================
How to reset the Password for ASMSNMP user in an ASM instance
====================================================================
Here we will see 2 methods to achieve it:

--#########################################
--# 1)  Using Alter User Command
--#########################################

$ export ORACLE_SID=+ASM
$ . oraenv
$ sqlplus / as sysasm

SQL> Alter user asmsnmp identified by <password>;
User altered.

--###############################################################################
--# 2)  Using ASMCMD Prompt. In a clusted environmet this method would update the password on all nodes in the cluster.
--###############################################################################

We can modify the password for ASMSNMP user using asmcmd command "orapwusr"

orapwusr --modify --password asmsnmp


[oracle@host01 ~]$ asmcmd -p
ASMCMD [+] > lspwusr
Username sysdba sysoper sysasm
     SYS   TRUE    TRUE   TRUE
 ASMSNMP   TRUE   FALSE  FALSE
ASMCMD [+] >

ASMCMD [+] > orapwusr --modify --password asmsnmp
Enter password: **********
ASMCMD [+] >


# 1 Connecting to the asm instance and executing an alter user

1
$ sqlplus / as sysasm Alter user asmsnmp identified by xxxxxxx;


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
Blocking SESSION
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
Query to check parallel query
select a.slave_name,a.sessions,a.idle_time_cur,a.cpu_secs_total,b.username,b.sid,b.program,b.sql_id from gv$pq_slave a,GV$SESSION  b.where a.sessions=b.sid order by slave_name;

Blocking Session Details
select l1.sid, ' IS BLOCKING ', l2.sid from gv$lock l1, gv$lock l2 where l1.block =1 and l2.request > 0 and l1.id1=l2.id1 and l1.id2=l2.id2;


select s1.username || '@' || s1.machine
|| ' ( SID=' || s1.sid || ' ) is blocking '
|| s2.username || '@' || s2.machine || ' ( SID=' || s2.sid || ' ) ' AS blocking_status
from gv$lock l1, gv$session s1, gv$lock l2, gv$session s2
where s1.sid=l1.sid and s2.sid=l2.sid
and l1.BLOCK=1 and l2.request > 0
and l1.id1 = l2.id1
and l2.id2 = l2.id2 ;

select inst_id,sid,serial#, username,sql_id, osuser,program, machine,event,
to_char(logon_time,'ddMon hh24:mi') login,last_call_et/60/60 "last call",status,type from
gv$session where last_call_et/60/60 > 1 and username not in 'SYS' and status='ACTIVE' and type<>'BACKGROUND' order by 7;

select inst_id,sid,serial#, username,sql_id, osuser,program, machine,event,
to_char(logon_time,'ddMon hh24:mi') login,last_call_et/60 "last call",status,type from
gv$session where last_call_et/60 > 1 and username not in 'SYS' and status='ACTIVE' and type<>'BACKGROUND' order by 11;

select l1.sid, ' IS BLOCKING ', l2.sid
from gv$lock l1, gv$lock l2
where l1.block =1 and l2.request > 0
and l1.id1=l2.id1
and l1.id2=l2.id2

query 1:
========
set lines 300
col OBJECT_NAME for a20
col OSUSER for a20
col OWNER for a20
col OBJECT_TYPE for a8
col MACHINE for a15
select
   c.owner,
   c.object_name,
   c.object_type,
   b.sid,
   b.serial#,
   b.status,
   b.osuser,
   b.machine
from
   v$locked_object a ,
   v$session b,
   dba_objects c
where
   b.sid = a.session_id
and
   a.object_id = c.object_id;


sample output:

OWNER                OBJECT_NAME          OBJECT_T        SID    SERIAL# STATUS   OSUSER               machine
-------------------- -------------------- -------- ---------- ---------- -------- -------------------- ---------------
SPORTSKIT            TRN_LIABILITY        TABLE            57      49546 ACTIVE   00511170             MKHO2LIS5011170
SPORTSKIT            TRN_LIABILITY        TABLE          1558       7221 INACTIVE 00511170             MKHO2LIS5011170
==================================================================
query 2:
===========
set lines 200
set pages 100
select (select username from v$session where sid=a.sid) blocker,a.sid,' is blocking ',(select username from v$session where sid=b.sid) blockee, b.sid
from v$lock a, v$lock b where a.block = 1 and b.request > 0 and a.id1 = b.id1 and a.id2 = b.id2;


sample output:
BLOCKER                                                                                                                                 SID 'ISBLOCKING'  BLOCKEE        SID
-------------------------------------------------------------------------------------------------------------------------------- ---------- ------------- -------------------------------------------------------------------------------------------------------------------------------- ----------
SPORTSKIT                                                                                                                              1558  is blocking  SPORTSKIT       57
SPORTSKIT                                                                                                                              1558  is blocking  SPORTSKIT     1540
SPORTSKIT                                                                                                                              1558  is blocking  SPORTSKIT     1546


select sid,serial#,status from v$session where sid='1558';

alter system kill session '1558,7221' immediate;

query 3:
========
SELECT a.sql_text, b.sql_hash_value
FROM   v$sqltext a,
       v$session b
WHERE  a.address = b.sql_address
AND    a.hash_value = b.sql_hash_value
AND    b.sid = &1
ORDER BY a.piece;

	SELECT
	   s.blocking_session, 
	   s.sid, 
	   s.serial#, 
	   s.seconds_in_wait
	FROM
	   v$session s
	WHERE
	   blocking_session IS NOT NULL;


sample output:
=============
BLOCKING_SESSION        SID    SERIAL# SECONDS_IN_WAIT
---------------- ---------- ---------- ---------------
             800         18      36755             855
             800         47      49134             855
===============================================================

query 4:
=======
column pu format a8 heading 'O/S|login|ID' justify left
column su format a8 heading 'Oracle/User ID' justify left
column prog format a35 heading 'Program' justify left
column machine format a15 heading 'machine' justify left
column stat format a8 heading 'Session|Status' justify left
column ssid format 999999 heading 'Oracle|Session|Id'  justify right
column sser format 999999 heading 'Oracle|Serial|No' justify right
column spid format 999999 heading 'Unix|Process|ID' justify right
column txt format a28 word heading 'SQL TEXT'
column RUNT format a15 word heading 'Run Time'
set pagesize 25

 select
 p.username pu,
 s.username su,
 s.status stat,
 s.program prog,
 s.machine machine,
 s.sid ssid,
 s.serial# sser,
 lpad(p.spid,7) spid,
  ltrim(to_char(floor(s.last_call_et/3600),'09')) ||':'
 || ltrim(to_char(floor(mod(s.last_call_et,3600)/60),'09')) ||':'
 || ltrim(to_char(mod(s.last_call_et,60),'09')) RUNTIME,
 substr(sa.sql_text,1,2000) txt
from v$process p,
 v$session s,
 v$sqlarea sa
where p.addr = s.paddr
 and s.username is not null
 and s.sql_address=sa.address(+)
 and s.sql_hash_value=sa.hash_value(+)
 --and s.program='TOAD.EXE'
order by 1,2,7
/

sample output:
============
O/S                                                                             Oracle  Oracle    Unix
login             Session                                                      Session  Serial Process
ID       Oracle/U Status   Program                             machine              Id      No      ID SQL TEXT                     Run Time
-------- -------- -------- ----------------------------------- --------------- ------- ------- ------- ---------------------------- ---------------
grid     ACCIDENT INACTIVE JDBC Thin Client                    mudvwebjbuat.ds    1539    3224   40154                              55:35:35
         REPORTIN                                              .indianoil.in
         G

grid     ACCIDENT INACTIVE JDBC Thin Client                    mudvwebjbuat.ds     788    6331   40146                              55:35:35
         REPORTIN                                              .indianoil.in
         G
=====================================================sql query exe=============

--SQL query exec time

select a.instance_number inst_id, a.snap_id,a.plan_hash_value, to_char(begin_interval_time,'dd-mon-yy hh24:mi') btime, abs(extract(minute from (end_interval_time-begin_interval_time)) + extract(hour from (end_interval_time-begin_interval_time))*60 + extract(day from (end_interval_time-begin_interval_time))*24*60) minutes,
executions_delta executions, round(ELAPSED_TIME_delta/1000000/greatest(executions_delta,1),4) "avg duration (sec)" from dba_hist_SQLSTAT a, dba_hist_snapshot b
where sql_id='&sql_id' and a.snap_id=b.snap_id
and a.instance_number=b.instance_number
order by snap_id desc, a.instance_number;

Query for RMAN backup status:
========================
set serveroutput on
set linesize 200 pagesize 300
col input_type for a15
col status for a25
set numwidth 20
col START_TIME for a30
col END_TIME for a30
col time_taken_display for a9
col output_bytes_display for a9
select session_key,
       input_type,
       status,
       to_char(start_time,'yyyy-mm-dd hh24:mi') start_time,
       to_char(end_time,'yyyy-mm-dd hh24:mi')   end_time,
       output_bytes_display,
       time_taken_display
from v$rman_backup_job_details where input_type like'%DB%' order by session_key Asc;

lock:
=====
col username format a8
col owner format a10
col sid format 99999
col serial# format 9999999
col inst_id format 999
col object_name format a30
col object_type format a12
col status format a8
select b.username,c.Owner,c.Object_Name,c.Object_Type,b.Sid,b.Serial#,b.Status,b.INST_ID
from gv$locked_object a ,gv$session b,dba_objects c where b.Sid = a.Session_Id
and a.Object_Id = c.Object_Id and b.status='ACTIVE'
/

wait:
=====
select sw.sid,s.username,sw.event,to_char(s.logon_time,'hh:mi:ss AM') TIME,sw.state,sw.seconds_in_wait sec_in_wait
from gv$session s, gv$session_wait sw
where s.username is not null
and s.username not in ('SYS','SYSTEM')
and sw.sid=s.sid
and sw.event not like '%SQL*Net%'
and s.status='ACTIVE'
and sw.event like 'enq%'
order by sw.seconds_in_wait ASC
/

===== Main (SESSION LOCKED) ===

set lines 200
select s1.username||'@'||s1.machine ||' - '||s1.program||' ( SID: ' || s1.sid || ', SERIAL#: '|| s1.serial#||', PID: '||p1.spid||',Wait_Event:'||sw1.Event||',Inactive_T
ime :'||round(s1.last_call_et/60,2)||' Min )  is blocking '|| s2.username||'@'|| s2.machine||' - '||s2.program||' ( SID: ' || s2.sid || ', SERIAL#: '|| s1.serial#|| ',
PID: '||p2.spid||' ) ' AS blocking_status from v$lock l1, v$session s1, v$lock l2, v$session s2,v$session_wait sw1,v$session_wait sw2, v$process p1 , v$process
p2 where s1.sid=l1.sid and s2.sid=l2.sid and l1.BLOCK=1 and l2.request > 0 and l1.id1 = l2.id1 and l1.id2 = l2.id2 and s1.PADDR = p1.ADDR and s2.PADDR = p2.ADDR and s1.
sid=sw1.sid and s2.sid=sw2.sid
/

Show which row is locked
============================

select	do.object_name
,	row_wait_obj#
,	row_wait_file#
,	row_wait_block#
,	row_wait_row#
,	dbms_rowid.rowid_create (1, ROW_WAIT_OBJ#, ROW_WAIT_FILE#, 
				ROW_WAIT_BLOCK#, ROW_WAIT_ROW#)
from	v$session s
,	dba_objects do
where	sid=&sid
and 	s.ROW_WAIT_OBJ# = do.OBJECT_ID
/

Show sessions that are blocking each other (DEAD LOCK)
=============================================

select	'SID ' || l1.sid ||' is blocking  ' || l2.sid blocking
from	v$lock l1, v$lock l2
where	l1.block =1 and l2.request > 0
and	l1.id1=l2.id1
and	l1.id2=l2.id2
/

select	l1.inst_id,'SID ' || l1.sid ||' is blocking  ' || l2.sid blocking
from	gv$lock l1, gv$lock l2
where	l1.block =1 and l2.request > 0
and	l1.id1=l2.id1
and	l1.id2=l2.id2
/



RMAN :This script will report status of current as well as completed backup details like full, incremental and archivelog backups:
==================================================================================================================================
col STATUS format a9
col hrs format 999.99
select
SESSION_KEY, INPUT_TYPE, STATUS,
to_char(START_TIME,'mm/dd/yy hh24:mi') start_time,
to_char(END_TIME,'mm/dd/yy hh24:mi')   end_time,
elapsed_seconds/3600                   hrs
from V$RMAN_BACKUP_JOB_DETAILS
order by session_key;

To know the rman SID:
======================================================================================================================
select * from gv$session where program like 'rman%' and status='ACTIVE';

Below script will report you the percentage of completion along with sid and serial#.
=======================================================================================
SELECT SID, SERIAL#, CONTEXT, SOFAR, TOTALWORK,
ROUND (SOFAR/TOTALWORK*100, 2) "% COMPLETE"
FROM V$SESSION_LONGOPS
WHERE OPNAME LIKE 'RMAN%' AND OPNAME NOT LIKE '%aggregate%'
AND TOTALWORK! = 0 AND SOFAR <> TOTALWORK;

restoration status:
===========================================================
select SID,OPERATION,STATUS,MBYTES_PROCESSED from v$rman_status where STATUS='RUNNING';
select SID,OPERATION,STATUS,MBYTES_PROCESSED/1024 as GB_PROCESSED from v$rman_status where STATUS='RUNNING';
select SID,OPERATION,STATUS,MBYTES_PROCESSED/1024/1024 as TB_PROCESSED from v$rman_status where STATUS='RUNNING';

restoration Throughput status:
===========================================================
TTITLE OFF
SET HEAD OFF
SELECT 'Throughput: '||
       ROUND(SUM(v.value/1024/1024/1024),1) || ' Gig so far @ ' ||
       ROUND(SUM(v.value     /1024/1024)/NVL((SELECT MIN(elapsed_seconds)
            FROM v$session_longops
            WHERE opname          LIKE 'RMAN: aggregate input'
              AND sofar           != TOTALWORK
              AND elapsed_seconds IS NOT NULL
       ),SUM(v.value     /1024/1024)),2) || ' Meg/sec'
FROM gv$sesstat v, v$statname n, gv$session s
WHERE v.statistic# = n.statistic#
  AND n.name       = 'physical write total bytes'
  AND v.sid        = s.sid
  AND v.inst_id    = s.inst_id
  AND s.program LIKE 'rman@%'
GROUP BY n.name
/


For Table details of particular time
=======================================================================================================
SELECT * FROM ESAHO.ESA_APP_QUERY_FORWARD_DETAILS
AS OF TIMESTAMP
TO_TIMESTAMP('2022-05-05 09:30:00', 'YYYY-MM-DD HH:MI:SS');

TOP TABLE IN DATABASE :-
===================================================================
select * from (
   select owner, segment_name, segment_type,bytes/1024/1024/1024 SIZE_GB
   from dba_segments
   where segment_type = 'TABLE'
   order by bytes/1024/1024/1024 desc)
where rownum <= 30;
   
For Table details of current time
=======================================================================================================
select * from ESAHO.ESA_APP_QUERY_FORWARD_DETAILS;

for Recovery Area Size
=======================================================================================================
select name, ROUND(SPACE_LIMIT/1024/1024/1024,2) "Allocated Space(GB)", 
round(SPACE_USED/1024/1024/1024,2) "Used Space(GB)",
round(SPACE_RECLAIMABLE/1024/1024/1024,2) "SPACE_RECLAIMABLE (GB)" ,
(select round(ESTIMATED_FLASHBACK_SIZE/1024/1024/1024,2) 
from V$FLASHBACK_DATABASE_LOG) "Estimated Space (GB)"
from V$RECOVERY_FILE_DEST;

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
DISK GROUP AND DATA_DG DETAILS
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
Create Disk
********************************

oracleasm createdisk OCRVOTE4DC01 /dev/sdv1
oracleasm createdisk OCRVOTE4DC02 /dev/sdw1
oracleasm createdisk OCRVOTE4DC03 /dev/sdx1

oracleasm createdisk REDO4DC01 /dev/sdad1
oracleasm createdisk REDO4DC02 /dev/sdac1

oracleasm createdisk ARCH4DC01 /dev/sdab1

oracleasm createdisk DATA4DC01 /dev/sdy1
oracleasm createdisk DATA4DC02 /dev/sdz1
oracleasm createdisk DATA4DC03 /dev/sdaa1

====================================================

add disk in diskgroup
********************************

alter diskgroup OCR_VOTE add disk '/dev/oracleasm/disks/OCRVOTE4DC01','/dev/oracleasm/disks/OCRVOTE4DC02','/dev/oracleasm/disks/OCRVOTE4DC02' rebalance power 8;
alter diskgroup REDO_01 add disk '/dev/oracleasm/disks/REDO4DC01' rebalance power 8;
alter diskgroup REDO_02 add disk '/dev/oracleasm/disks/REDO4DC02' rebalance power 8;
alter diskgroup ARCH_DG add disk '/dev/oracleasm/disks/ARCH4DC01' rebalance power 8;
alter diskgroup DATA_DG add disk '/dev/oracleasm/disks/DATA4DC01','/dev/oracleasm/disks/DATA4DC02','/dev/oracleasm/disks/DATA4DC03' rebalance power 8;

Mount stage OF FRA_DG
======================================================================
ASMCMD> mount FRA_DG


drop disk in diskgroup
********************************

alter diskgroup OCR_VOTE drop disk 'OCRVOTE4DC01','OCRVOTE4DC02','OCRVOTE4DC02' rebalance power 8;
alter diskgroup REDO_01 drop disk 'REDO4DC01' rebalance power 8;
alter diskgroup REDO_02 drop disk 'REDO4DC02' rebalance power 8;
alter diskgroup ARCH_DG drop disk 'ARCH4DC01' rebalance power 8;
alter diskgroup DATA_DG drop disk 'DATA4DC01','DATA4DC02','DATA4DC03' rebalance power 8;


select * from v$asm_operation;
=============================================================================
-----For MB calclutation
SET LINESIZE  145
SET PAGESIZE  9999
SET VERIFY    off
COLUMN group_name             FORMAT a20           HEAD 'Disk Group|Name'
COLUMN sector_size            FORMAT 99,999        HEAD 'Sector|Size'
COLUMN block_size             FORMAT 99,999        HEAD 'Block|Size'
COLUMN allocation_unit_size   FORMAT 999,999,999   HEAD 'Allocation|Unit Size'
COLUMN state                  FORMAT a11           HEAD 'State'
COLUMN type                   FORMAT a6            HEAD 'Type'
COLUMN total_mb               FORMAT 999,999,999   HEAD 'Total Size (MB)'
COLUMN used_mb                FORMAT 999,999,999   HEAD 'Used Size (MB)'
COLUMN pct_used               FORMAT 999.99        HEAD 'Pct. Used'
break on report on disk_group_name skip 1
compute sum label "Grand Total: " of total_mb used_mb on report

SELECT 
	name 									 group_name,
	sector_size 							 sector_size,
	block_size                               block_size,
	allocation_unit_size                     allocation_unit_size,
	state                                    state,
	type                                     type,
	total_mb                                 total_mb,
	(total_mb - free_mb)                     used_mb,
	ROUND((1- (free_mb / total_mb))*100, 2)  pct_used
  FROM v$asm_diskgroup ORDER BY name;
  
  
  -----For GB calclutation
SET LINESIZE  145
SET PAGESIZE  9999
SET VERIFY    off
COLUMN group_name             FORMAT a20           HEAD 'Disk Group|Name'
COLUMN sector_size            FORMAT 99,999        HEAD 'Sector|Size'
COLUMN block_size             FORMAT 99,999        HEAD 'Block|Size'
COLUMN allocation_unit_size   FORMAT 999,999,999   HEAD 'Allocation|Unit Size'
COLUMN state                  FORMAT a11           HEAD 'State'
COLUMN type                   FORMAT a6            HEAD 'Type'
COLUMN total_gb               FORMAT 999,999,999   HEAD 'Total Size (GB)'
COLUMN used_gb                FORMAT 999,999,999   HEAD 'Used Size (GB)'
COLUMN pct_used               FORMAT 999.99        HEAD 'Pct. Used'
break on report on disk_group_name skip 1
compute sum label "Grand Total: " of total_gb used_gb on report

SELECT 
	name 									 group_name,
	sector_size 							 sector_size,
	block_size                               block_size,
	allocation_unit_size                     allocation_unit_size,
	state                                    state,
	type                                     type,
	total_mb/1024                            total_gb,
	(total_mb/1024 - free_mb/1024)           used_gb,
	ROUND((1- ((free_mb/1024) / (total_mb/1024)))*100, 2)  pct_used
  FROM v$asm_diskgroup ORDER BY name;



break on report on disk_group_name skip 1
compute sum label "Grand Total: " of TOTALGB FREEGB USEDGB on report
select name, state, round(total_mb/1024,2) TOTALGB,round(free_mb/1024,2)FREEGB,round(cold_used_mb/1024,2)USEDGB,
round(100 * (cold_used_mb / total_mb)) " Pct. Used" from v$asm_diskgroup;


  
SQL> select name, state, round(total_mb/1024,2) TOTALGB,round(free_mb/1024,2)FREEGB,round(cold_used_mb/1024,2)USEDGB,
round(100 * (cold_used_mb / total_mb)) " Pct. Used" from v$asm_diskgroup;  2

NAME                           STATE          TOTALGB     FREEGB     USEDGB  Pct. Used
------------------------------ ----------- ---------- ---------- ---------- ----------
ARCH_DG                        CONNECTED          500     315.22     184.77         37
DATA_DG                        CONNECTED      1999.98     587.41    1412.57         71
REDO_01                        CONNECTED           30      28.51       1.48          5

SQL>
SQL> select path, header_status, os_mb/1024 as GB from v$asm_disk where header_status <> 'MEMBER' order by 1;

SQL> select GROUP_NUMBER,DISK_NUMBER,HEADER_STATUS,TOTAL_MB/1024,FREE_MB/1024,PATH,NAME from v$asm_disk order by 7,6;
sql> SELECT NAME,PATH,OS_MB/1024,TOTAL_MB/1024,FREE_MB/1024,MODE_STATUS,HEADER_STATUS FROM V$ASM_DISK order by 1,2;
check allotted diskgroup as provisoned 

fire this command
SQL> alter diskgroup ARCH_DG add disk '/dev/oracleasm/disks/ARCH_03';
check new diskgroup marked as member


This query shows the amount of free space for each disk:
========================================================
col name format a20
col path format a50
break on report on disk_group_name skip 1
compute sum label "Grand Total: " of TOTAL_GB FREE_GB on report
select dg.name, d.name, d.path, round(d.total_mb/1024,2) as TOTAL_GB , round(d.free_mb/1024,2) AS FREE_GB
  from v$asm_diskgroup dg, 
       v$asm_disk d
 where d.group_number = dg.group_number
 order by 1, 2;
------------------------------------------------------------------------------

set pagesize 9999
set line 9999
col DISKGROUP for a30
SELECT dg.name, SUBSTR(d.name,1,16) AS asmdisk,d.TOTAL_MB/1024 as ASSIGN_SIZE, d.mount_status, d.state
       AS diskgroup FROM V$ASM_DISKGROUP dg, V$ASM_DISK d
     WHERE dg.group_number = d.group_number order by asmdisk;
	 
	 
set pagesize 9999
set line 9999
col DISKGROUP for a30
SELECT dg.name, SUBSTR(d.name,1,16) AS asmdisk,d.TOTAL_MB/1024 as ASSIGN_SIZE, d.mount_status, d.state
       AS diskgroup FROM V$ASM_DISKGROUP dg, V$ASM_DISK d
     WHERE dg.group_number = d.group_number;

NAME                           ASMDISK          ASSIGN_SIZE MOUNT_S DISKGROU
------------------------------ ---------------- ----------- ------- --------
ARCH_DG                        ARCH_01           1023.99902 CACHED  NORMAL
ARCH_DG                        ARCH_02           1023.99902 CACHED  NORMAL
DATA_DG01                      DATA_01           1023.99902 CACHED  NORMAL
DATA_DG02                      DATA_02           1023.99902 CACHED  NORMAL
DATA_DG03                      DATA_03           1023.99902 CACHED  NORMAL
DATA_DG03                      DATA_04           1023.99902 CACHED  NORMAL
FRA_DG                         FRA_01            1023.99902 CACHED  NORMAL
OCR_VOTE                       OCR_VOTE_01       49.9990234 CACHED  NORMAL
OCR_VOTE                       OCR_VOTE_02       49.9990234 CACHED  NORMAL
OCR_VOTE                       OCR_VOTE_03       49.9990234 CACHED  NORMAL
REDO_01                        REDO_01           199.999023 CACHED  NORMAL
REDO_02                        REDO_02           199.999023 CACHED  NORMAL
REDO_01                        REDO_03           259.999023 CACHED  NORMAL
REDO_02                        REDO_04           259.999023 CACHED  NORMAL

28 rows selected.

Using username "oracle".
Last login: Wed Mar 16 22:24:34 2022 from 10.146.77.115
Server IP= 10.146.66.18
ORACLE_HOME=/oracle/app/oracle/product/19.3.0/dbhome_1
ORACLE_SID=MKTORADEV
[oracle@mktoradev5 ~]$
[oracle@mktoradev5 ~]$
[oracle@mktoradev5 ~]$
[oracle@mktoradev5 ~]$ 
[oracle@mktoradev5 disks]$ ls -lrth
total 0
brw-rw---- 1 grid asmadmin 8, 129 Mar 16 22:25 DATA03
brw-rw---- 1 grid asmadmin 8, 113 Mar 16 22:25 DATA02
brw-rw---- 1 grid asmadmin 8,  65 Mar 16 22:25 REDO
brw-rw---- 1 grid asmadmin 8,  33 Mar 16 22:25 DATA01
brw-rw---- 1 grid asmadmin 8,  49 Mar 16 22:25 ARCH01
[oracle@mktoradev5 disks]$
[oracle@mktoradev5 disks]$
[oracle@mktoradev5 disks]$
[oracle@mktoradev5 disks]$
[oracle@mktoradev5 disks]$
[oracle@mktoradev5 disks]$ su - root
Password:
Last login: Wed Mar 16 08:35:34 IST 2022 on pts/1
Last failed login: Wed Mar 16 09:33:01 IST 2022 on pts/0
There was 1 failed login attempt since the last successful login.
[root@mktoradev5 ~]#
[root@mktoradev5 ~]# lsblk
NAME                MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda                   8:0    0  150G  0 disk
├─sda1                8:1    0  512M  0 part /boot
├─sda2                8:2    0  140G  0 part
│ ├─rhel-root       253:0    0   60G  0 lvm  /
│ ├─rhel-usr        253:1    0   20G  0 lvm  /usr
│ ├─rhel-var        253:4    0   50G  0 lvm  /var
│ ├─rhel-home       253:5    0   20G  0 lvm  /home
│ ├─rhel-opt        253:6    0  100G  0 lvm  /opt
│ └─rhel-srv        253:7    0   20G  0 lvm  /srv
└─sda3                8:3    0    8G  0 part [SWAP]
sdb                   8:16   0  450G  0 disk
├─rhel-root         253:0    0   60G  0 lvm  /
├─rhel-var          253:4    0   50G  0 lvm  /var
├─rhel-opt          253:6    0  100G  0 lvm  /opt
├─rhel-tmp          253:8    0   20G  0 lvm  /tmp
├─rhel-oracle       253:9    0  150G  0 lvm  /oracle
└─rhel-oragrid      253:10   0  150G  0 lvm  /oragrid
sdc                   8:32   0  500G  0 disk
└─sdc1                8:33   0  500G  0 part
sdd                   8:48   0  500G  0 disk
└─sdd1                8:49   0  500G  0 part
sde                   8:64   0   30G  0 disk
└─sde1                8:65   0   30G  0 part
sdf                   8:80   0  500G  0 disk
└─backup-backuplv   253:2    0  500G  0 lvm  /backup
sdg                   8:96   0   25G  0 disk
└─vg--monitor-lvol0 253:3    0   25G  0 lvm  /db_monitor
sdh                   8:112  0  500G  0 disk
└─sdh1                8:113  0  500G  0 part
sdi                   8:128  0  500G  0 disk
└─sdi1                8:129  0  500G  0 part
sdj                   8:144  0  500G  0 disk
└─sdj1                8:145  0  500G  0 part
[root@mktoradev5 ~]#
[root@mktoradev5 ~]# oracleasm listdisks
ARCH01
DATA01
DATA02
DATA03
REDO
[root@mktoradev5 ~]#
[root@mktoradev5 ~]# oracleasm createdisk DATA04 /dev/sdj1
Writing disk header: done
Instantiating disk: done
[root@mktoradev5 ~]#
[root@mktoradev5 ~]# oracleasm scandisks
Reloading disk partitions: done
Cleaning any stale ASM disks...
Scanning system for ASM disks...
[root@mktoradev5 ~]#
[root@mktoradev5 ~]# oracleasm listdisks
ARCH01
DATA01
DATA02
DATA03
DATA04
REDO
[root@mktoradev5 ~]# cd /dev/oracleasm/disks/
[root@mktoradev5 disks]# ls -lrth
total 0
brw-rw---- 1 grid asmadmin 8, 145 Mar 16 22:29 DATA04
brw-rw---- 1 grid asmadmin 8, 129 Mar 16 22:29 DATA03
brw-rw---- 1 grid asmadmin 8, 113 Mar 16 22:29 DATA02
brw-rw---- 1 grid asmadmin 8,  65 Mar 16 22:29 REDO
brw-rw---- 1 grid asmadmin 8,  33 Mar 16 22:29 DATA01
brw-rw---- 1 grid asmadmin 8,  49 Mar 16 22:29 ARCH01
[root@mktoradev5 disks]#
[root@mktoradev5 disks]#
[root@mktoradev5 disks]# pwd
/dev/oracleasm/disks
[root@mktoradev5 disks]# exit

[oracle@mktoradev5 disks]$ su - grid
Password:
Last login: Wed Mar 16 22:31:54 IST 2022 on pts/2
Server IP=10.146.66.18
GRID_HOME=/oragrid/app/product/19.3.0/grid
ALERT_HOME=
[grid@mktoradev5 ~]$
[grid@mktoradev5 ~]$
[grid@mktoradev5 ~]$ ps -ef|grep pmon
grid      11128      1  0 Mar12 ?        00:00:16 asm_pmon_+ASM
grid      12167  11467  0 22:41 pts/1    00:00:00 grep --color=auto pmon
oracle    13561      1  0 Mar12 ?        00:00:34 ora_pmon_MKTORADEV
[grid@mktoradev5 ~]$
[grid@mktoradev5 ~]$
[grid@mktoradev5 ~]$
[grid@mktoradev5 ~]$ . oraenv
ORACLE_SID = [grid] ? +ASM
The Oracle base has been set to /oragrid/app/product/19.3.0/grid_base
[grid@mktoradev5 ~]$
[grid@mktoradev5 ~]$
[grid@mktoradev5 ~]$ sqlplus "/as sysasm"

SQL*Plus: Release 19.0.0.0.0 - Production on Wed Mar 16 22:41:39 2022
Version 19.12.0.0.0

Copyright (c) 1982, 2021, Oracle.  All rights reserved.


Connected to:
Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production
Version 19.12.0.0.0

SQL>
SQL>
SQL> alter diskgroup DATA_DG add disk '/dev/oracleasm/disks/DATA04';

Diskgroup altered.

SQL>

[root@retailora01 disks]# oracleasm querydisk /dev/* | grep " marked an ASM disk"
[root@retailora01 disks]# oracleasm querydisk /dev/sdd*
Device "/dev/sdd" is not marked as an ASM disk
[root@retailora01 disks]# oracleasm querydisk /dev/sde*
Device "/dev/sde" is not marked as an ASM disk
[root@retailora01 disks]#

[root@retailora01 ~]# oracleasm querydisk /dev/oracleasm* | grep label
Device "/dev/sdac1" is marked an ASM disk with the label "DATA_13"
Device "/dev/sdad1" is marked an ASM disk with the label "DATA_DG14"
Device "/dev/sdae1" is marked an ASM disk with the label "DATA_15"
Device "/dev/sdaf1" is marked an ASM disk with the label "DATA_16"
Device "/dev/sdah1" is marked an ASM disk with the label "ARCH_03"
Device "/dev/sdai1" is marked an ASM disk with the label "ARCH_04"
Device "/dev/sdd1" is marked an ASM disk with the label "ARCH_01"
Device "/dev/sde1" is marked an ASM disk with the label "ARCH_02"
Device "/dev/sdf1" is marked an ASM disk with the label "DATA_01"
Device "/dev/sdg1" is marked an ASM disk with the label "DATA_02"
Device "/dev/sdh1" is marked an ASM disk with the label "DATA_03"
Device "/dev/sdi1" is marked an ASM disk with the label "DATA_04"
Device "/dev/sdj1" is marked an ASM disk with the label "DATA_05"
Device "/dev/sdk1" is marked an ASM disk with the label "DATA_06"
Device "/dev/sdl1" is marked an ASM disk with the label "DATA_07"
Device "/dev/sdm1" is marked an ASM disk with the label "DATA_08"
Device "/dev/sdn1" is marked an ASM disk with the label "DATA_09"
Device "/dev/sdo1" is marked an ASM disk with the label "DATA_10"
Device "/dev/sdp1" is marked an ASM disk with the label "DATA_11"
Device "/dev/sdq1" is marked an ASM disk with the label "OCR_VOTE_01"
Device "/dev/sdr1" is marked an ASM disk with the label "OCR_VOTE_02"
Device "/dev/sds1" is marked an ASM disk with the label "OCR_VOTE_03"
Device "/dev/sdt1" is marked an ASM disk with the label "REDO_01"
Device "/dev/sdu1" is marked an ASM disk with the label "REDO_02"
Device "/dev/sdv1" is marked an ASM disk with the label "REDO_03"
Device "/dev/sdw1" is marked an ASM disk with the label "REDO_04"
Device "/dev/sdx1" is marked an ASM disk with the label "FRA_01"
Device "/dev/sdy1" is marked an ASM disk with the label "DATA_12"
[root@retailora01 ~]#



XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
FINDING ORACLE_HOME
=========================================================================================
[root@mudcvoranewrel01 ~]# pgrep  -lf _pmon_
1726935 asm_pmon_+asm1
1867961 ora_pmon_iocl1
2092969 ora_pmon_orcl1
[root@mudcvoranewrel01 ~]#
[root@mudcvoranewrel01 ~]# pwdx 1867961
1867961: /oracle/app/oracle/homes/OraDB21Home1/dbs
[root@mudcvoranewrel01 ~]#
[root@mudcvoranewrel01 ~]#
[root@mudcvoranewrel01 ~]# pwdx 2092969
2092969: /oracle/app/oracle/homes/OraDB21Home1/dbs
[root@mudcvoranewrel01 ~]#
[root@mudcvoranewrel01 ~]# pwdx 1726935
1726935: /oragrid/app/product/21.0.0/grid/dbs
[root@mudcvoranewrel01 ~]#

=========================================================================================
CDB AND PDBs
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
sql> select CON_ID,GUID,NAME,OPEN_MODE,RESTRICTED,OPEN_TIME,CREATION_TIME,GUID_BASE64,CLOSE_TIME from V$CONTAINERS;

SQL> show pdbs

    CON_ID CON_NAME                       OPEN MODE  RESTRICTED
---------- ------------------------------ ---------- ----------
         2 PDB$SEED                       READ ONLY  NO
         3 OJAS_PDB                       READ WRITE NO
SQL> alter session set container=OJAS_PDB;
  
Session altered.

SQL> show con_name;

CON_NAME
------------------------------
CDB$ROOT

SQL> show con_name;

CON_NAME
------------------------------
OJAS_PDB



crsctl / srvctl / olsnodes commands
==========================================
STARTUP AND SHUTDOWN
======================================
Precheck Activity
------------------
#crsctl stat res -t
#ps -ef|grep pmon
#ps -ef|grep tns
#lsnrctl status listener
#srvctl config database
#srvctl status database -d NDSOFTDB -v
#srvctl status service -d NDSOFTDB  -v
# srvctl config database -d NDSOFTDB
#crsctl config crs
#crsctl check crs
[oracle@mudcvoragenuat01 ~]$ env | grep ORA
ORACLE_SID=GENUAT1
ORACLE_HOME=/oracle/app/product/19.0.0/dbhome_1
[oracle@mudcvoragenuat01 ~]$

Activity Node 1:-

STOP
#srvctl stop instance -d TESTIRASORADB -i TESTIRASORADB1
#srvctl status database -d TESTIRASORADB -
#crsctl stop crs
#crsctl check crs & crsctl check cluster -all

START
#crsctl check crs
#crsctl start crs
If require crsctl start res ora.crsd -init
#srvctl start instance -d TESTIRASORADB -i TESTIRASORADB1
#srvctl status database -d TESTIRASORADB -v


crsctl check crs 
crsctl stop crs
crsctl start crs 

DATABASE SHUTDOWN (BOTH NODE)
======================================================
Login as Oracle user
---------------
srvctl config database
srvctl status database -d NDSOFTDB -v
srvctl status database -d NDSOFTDB 
srvctl stop database -d NDSOFTDB 
srvctl start database -d NDSOFTDB
======================================================
CLUSTER SHUTDOWN
======================================================
Login as root user
------------------
cd <CRS_HOME>
cd $ORACLE_HOME/bin/
./crsctl check cluster -all
./crsctl stop cluster -all
./crsctl start cluster -all
./crsctl stat res -t 
./crsctl stat res -t -init
./crsctl stop crs
./crsctl stop crs -f
./crsctl start crs

======================================================
DATABASE SHUTDOWN (SINGLE NODE)
======================================================
cd <CRS_HOME>
cd $ORACLE_HOME/bin
./crsctl stop has

[grid@mudcvoragenuat01 ~]$ srvctl status nodeapps -n mudcvoragenuat01
VIP 10.146.66.129 is enabled
VIP 10.146.66.129 is running on node: mudcvoragenuat01
Network is enabled
Network is running on node: mudcvoragenuat01
ONS is enabled
ONS daemon is running on node: mudcvoragenuat01
[grid@mudcvoragenuat01 ~]$
[grid@mudcvoragenuat01 ~]$ srvctl status asm -n mudcvoragenuat01
ASM is running on mudcvoragenuat01
[grid@mudcvoragenuat01 ~]$
[grid@mudcvoragenuat01 ~]$ srvctl config database
GENUAT
[grid@mudcvoragenuat01 ~]$
[grid@mudcvoragenuat01 ~]$ srvctl status database -d GENUAT
Instance GENUAT1 is running on node mudcvoragenuat01
Instance GENUAT2 is running on node mudcvoragenuat02
[grid@mudcvoragenuat01 ~]$
[grid@mudcvoragenuat01 ~]$ srvctl status database -d GENUAT -v
Instance GENUAT1 is running on node mudcvoragenuat01. Instance status: Open.
Instance GENUAT2 is running on node mudcvoragenuat02. Instance status: Open.
[grid@mudcvoragenuat01 ~]$
[grid@mudcvoragenuat01 ~]$ srvctl config database -d GENUAT
Database unique name: GENUAT
Database name: GENUAT
Oracle home: /oracle/app/product/19.0.0/dbhome_1
Oracle user: oracle
Spfile: +DATA_DG/spfileGENUAT
Password file:
Domain:
Start options: open
Stop options: immediate
Database role: PRIMARY
Management policy: AUTOMATIC
Server pools:
Disk Groups: DATA_DG,REDO_01,REDO_02,ARCH_DG
Mount point paths:
Services:
Type: RAC
Start concurrency:
Stop concurrency:
OSDBA group: dba
OSOPER group: oper
Database instances: GENUAT1,GENUAT2
Configured nodes: mudcvoragenuat01,mudcvoragenuat02
CSS critical: no
CPU count: 0
Memory target: 0
Maximum memory: 0
Default network number for database services:
Database is administrator managed
[grid@mudcvoragenuat01 ~]$
[grid@mudcvoragenuat01 ~]$
[grid@mudcvoragenuat01 ~]$  srvctl stop database -d GENUAT
[grid@mudcvoragenuat01 ~]$  srvctl start database -d GENUAT
[grid@mudcvoragenuat01 ~]$  srvctl stop database -d GENUAT 
[grid@mudcvoragenuat01 ~]$ srvctl status scan_listener
SCAN Listener LISTENER_SCAN1 is enabled
SCAN listener LISTENER_SCAN1 is running on node mudcvoragenuat02
SCAN Listener LISTENER_SCAN2 is enabled
SCAN listener LISTENER_SCAN2 is running on node mudcvoragenuat01
SCAN Listener LISTENER_SCAN3 is enabled
SCAN listener LISTENER_SCAN3 is running on node mudcvoragenuat01
[grid@mudcvoragenuat01 ~]$
[grid@mudcvoragenuat01 ~]$ srvctl config scan_listener
SCAN Listeners for network 1:
Registration invited nodes:
Registration invited subnets:
Endpoints: TCP:1521
SCAN Listener LISTENER_SCAN1 exists
SCAN Listener is enabled.
SCAN Listener LISTENER_SCAN2 exists
SCAN Listener is enabled.
SCAN Listener LISTENER_SCAN3 exists
SCAN Listener is enabled.
[grid@mudcvoragenuat01 ~]$

[oracle@mudcvporairas01 ~]$ $ORACLE_HOME/OPatch/opatch version
OPatch Version: 12.2.0.1.21

OPatch succeeded.
[oracle@mudcvporairas01 ~]$ $ORACLE_HOME/OPatch/opatch lspatches
31772784;OCW RELEASE UPDATE 19.9.0.0.0 (31772784)
31771877;Database Release Update : 19.9.0.0.201020 (31771877)

OPatch succeeded.
[oracle@mudcvporairas01 ~]$

[grid@mudcvporairas01 ~]$ $ORACLE_HOME/OPatch/opatch lspatches
32918050;TOMCAT RELEASE UPDATE 19.0.0.0.0 (32918050)
32916816;OCW RELEASE UPDATE 19.12.0.0.0 (32916816)
32915586;ACFS RELEASE UPDATE 19.12.0.0.0 (32915586)
32904851;Database Release Update : 19.12.0.0.210720 (32904851)
32585572;DBWLM RELEASE UPDATE 19.0.0.0.0 (32585572)

OPatch succeeded.
[grid@mudcvporairas01 ~]$

[root@mudcvoranewrel01 bin]# ./crsctl query crs releaseversion
Oracle High Availability Services release version on the local node is [21.0.0.0.0]


[root@mudcvoranewrel01 bin]#  ./crsctl query crs softwareversion
Oracle Clusterware version on node [mudcvoranewrel01] is [21.0.0.0.0]


[root@mudcvoranewrel01 bin]# ./crsctl query crs softwareversion -all
Oracle Clusterware version on node [mudcvoranewrel01] is [21.0.0.0.0]
Oracle Clusterware version on node [mudcvoranewrel02] is [21.0.0.0.0]


[root@mudcvoragenuat01 ~]# cd /oragrid/app/product/19.0.0/grid/bin/
[root@mudcvoragenuat01 bin]#
[root@mudcvoragenuat01 bin]#
[root@mudcvoragenuat01 bin]# ./crsctl query crs releasepatch
Oracle Clusterware release patch level is [3998055650] and the complete list of patches [32585572 32904851 32915586 32916816 32918050 ] have been applied on the local node. The release patch string is [19.12.0.0.0].
[root@mudcvoragenuat01 bin]#

[root@mudcvoranewrel01 bin]# ./olsnodes -s
mudcvoranewrel01        Active
mudcvoranewrel02        Active
[root@mudcvoranewrel01 bin]#
[root@mudcvoranewrel01 bin]# ./olsnodes -n
mudcvoranewrel01        1
mudcvoranewrel02        2
[root@mudcvoranewrel01 bin]# ./olsnodes -n -t
mudcvoranewrel01        1       Unpinned
mudcvoranewrel02        2       Unpinned

[oracle@mudcvoranewrel01 ~]$ srvctl -version
srvctl version: 21.0.0.0.0
[oracle@mudcvoranewrel01 ~]$ srvctl -fullversion
srvctl full version: 21.3.0.0.0
[oracle@mudcvoranewrel01 ~]$

[root@mudcvoranewrel01 bin]# ./crsctl config crs
CRS-4622: Oracle High Availability Services autostart is enabled.
[root@mudcvoranewrel01 bin]#

[root@mudcvoranewrel01 bin]# ./crsctl disable crs
CRS-4621: Oracle High Availability Services autostart is disabled.
[root@mudcvoranewrel01 bin]#

[root@mudcvoranewrel01 bin]# ./crsctl enable crs
CRS-4622: Oracle High Availability Services autostart is enabled.
[root@mudcvoranewrel01 bin]#



cat alert_MKTRETAILDB1.log | grep ORA-

RMAN COMMANDS:
---------------------
select inst_id, username,osuser,machine,program,status from gv$session where program like '%rman@%';
select 'alter system kill session ' ||''''||SID||','||SERIAL#||',@'||inst_id||''''||' immediate ;' from gv$session where   program like '%rman@%' order by inst_id;

***************************************
OEM QUERIES
========================
alter session set nls_date_format = 'DD-MON-YYYY HH24:MI:SS';

For all the database backup details query run on OEM:-

select db_name,input_type,
output_device_type,status,
output_bytes_display,time_taken_display,
to_char(start_time,'DD/MM/YYYY HH24:MI') start_time,
to_char(end_time,'DD/MM/YYYY HH24:MI') end_time,
to_char(end_time,'DAY') dayofendtime
from RMAN_CAT.RC_RMAN_BACKUP_JOB_DETAILS where start_time > sysdate - 1
order by db_name,input_type;

For all the database sync status query run on OEM:-

WITH qb_get_dgmetrics AS (
     select 
          target_name
              , MAX( case when column_label = 'Apply Lag (seconds)' then to_number(value) end ) as apply_lag
          , MAX( case when column_label = 'Transport Lag (seconds)' then to_number(value) end ) as transport_lag
          , MAX( case when column_label = 'Apply Lag Data Refresh Time' then value end ) as Apply_Refresh_Time
          , MAX( case when column_label = 'Transport Lag Data Refresh Time' then value end ) as Transport_Refresh_Time
          , collection_timestamp
     from mgmt$metric_current
     where metric_name like '%dataguard%'
    and metric_label = 'Data Guard Performance' 
     and column_label in ('Apply Lag (seconds)', 'Transport Lag (seconds)','Apply Lag Data Refresh Time','Transport Lag Data Refresh Time' )
     group by target_name, collection_timestamp
)
select
     target_name
     , apply_lag
     , transport_lag
     , Apply_Refresh_Time
     , Transport_Refresh_Time
     , collection_timestamp 
from qb_get_dgmetrics order by target_name;

file system use

with FSsize as
(select collection_timestamp, lower(target_name) hostname, round((value/1024),0) size_gb , key_value filesystem
from SYSMAN.mgmt$metric_current
where metric_name ='Filesystems'
  and trunc(collection_timestamp) = trunc(sysdate)
  and metric_column = 'size'),
FSAvailable as
(select collection_timestamp, lower(target_name) hostname, round((value/1024),0) size_gb , key_value filesystem
from SYSMAN.mgmt$metric_current
where metric_name ='Filesystems'
  and trunc(collection_timestamp) = trunc(sysdate)
  and metric_column = 'available'),
FSpctAvailable as
(select collection_timestamp, lower(target_name) hostname, round(value,2) pctAvailable , key_value filesystem
from SYSMAN.mgmt$metric_current
where metric_name ='Filesystems'
  and trunc(collection_timestamp) = trunc(sysdate)
  and metric_column = 'pctAvailable'
)
select
   a.collection_timestamp ts#
   , a.hostname
   , a.filesystem "Mounted on"
   , a.size_gb "FS_Size_GB"
   , (a.size_gb-b.size_gb) "FS_Used_GB"
   , b.size_gb "FS_Available_GB"
   , c.pctavailable "Fs_Free_%"
   , 100-c.pctavailable "Fs_Used_%"
from FSsize a, FSAvailable b, FSpctAvailable c
where c.hostname = a.hostname and c.hostname = b.hostname
and c.collection_timestamp = a.collection_timestamp and c.collection_timestamp = b.collection_timestamp
and c.filesystem = a.filesystem and c.filesystem = b.filesystem
and c.filesystem in  ('/oracle','/oragrid','/mnt/backup','/backup','/var','/backup_temp') order by a.hostname

ASM diskgroup USE
===========================================
with FSsize as
(select collection_timestamp, lower(target_name) hostname, round((value/1024),0) size_gb , key_value filesystem
from SYSMAN.mgmt$metric_current
where metric_name ='DiskGroup_Usage'
  and trunc(collection_timestamp) = trunc(sysdate)
  and metric_column = 'total_mb'),
FSAvailable as
(select collection_timestamp, lower(target_name) hostname, round((value/1024),0) size_gb , key_value filesystem
from SYSMAN.mgmt$metric_current
where metric_name ='DiskGroup_Usage'
  and trunc(collection_timestamp) = trunc(sysdate)
  and metric_column = 'free_mb'),
FSpctAvailable as
(select collection_timestamp, lower(target_name) hostname, round(value,2) pctused , key_value filesystem
from SYSMAN.mgmt$metric_current
where metric_name ='DiskGroup_Usage'
  and trunc(collection_timestamp) = trunc(sysdate)
  and metric_column = 'percent_used'
)
select
   a.collection_timestamp ts#
   , a.hostname
   , a.filesystem "Mounted on"
   , a.size_gb "Total_Size_GB"
   , b.size_gb "Free size GB"
   , c.pctused "PCT Used %"
   , 100-c.pctused "Free %"
from FSsize a, FSAvailable b, FSpctAvailable c
where c.hostname = a.hostname and c.hostname = b.hostname
and c.collection_timestamp = a.collection_timestamp and c.collection_timestamp = b.collection_timestamp
and c.filesystem = a.filesystem and c.filesystem = b.filesystem
and c.filesystem not like 'REDO%' and  c.filesystem not like 'OCR%' order by a.hostname



Managing Availibility of Tablespaces in Oracle
==========================================================
Taking tablespaces Offline or Online
You can take an online tablespace offline so that it is temporarily unavailable for general use. The rest of the database remains open and available for users 
to access data. Conversely, you can bring an offline tablespace online to make the schema objects within the tablespace available to database users. The database must be open to alter the availability of a tablespace.

We usually take tablespaces offline for maintenance purposes.

To alter the availability of a tablespace, use the ALTER TABLESPACE statement. You must have the ALTER TABLESPACE or MANAGE TABLESPACE system privilege.

To Take a Tablespace Offline give the following command

SQL>alter tablespace ica offline;

To again bring it back online give the following command.

SQL>alter tablespace ica online;

To take individual datafile offline type the following command

SQL>alter database datafile '/u01/oracle/ica/ica_tbs01.dbf' offline;

Again to bring it back online give the following command

SQL> alter database datafile '/u01/oracle/ica/ica_tbs01.dbf' online;

Note: You can’t take individual datafiles offline it the database is running in NOARCHIVELOG mode.  If the datafile has become corrupt or missing when the database is running in NOARCHIVELOG mode then you can only drop it by giving the following command

SQL>alter database datafile '/u01/oracle/ica/ica_tbs01.dbf' offline for drop;

Making a Tablespace Read only.
Making a tablespace read-only prevents write operations on the datafiles in the tablespace. The primary purpose of read-only tablespaces is to eliminate the need to perform backup and recovery of large, static portions of a database. Read-only tablespaces also provide a way to protecting historical data so that users cannot modify it. Making a tablespace read-only prevents updates on all tables in the tablespace, regardless of a user's update privilege level.

To make a tablespace read only

SQL>alter tablespace ica read only

Again to make it read write

SQL>alter tablespace ica read write;

Renaming Tablespaces
Using the RENAME TO clause of the ALTER TABLESPACE, you can rename a permanent or temporary tablespace. For example, the following statement renames the users tablespace:

ALTER TABLESPACE users RENAME TO usersts;

The following affect the operation of this statement:

The COMPATIBLE parameter must be set to 10.0 or higher.
If the tablespace being renamed is the SYSTEM tablespace or the SYSAUX tablespace, then it will not be renamed and an error is raised.
If any datafile in the tablespace is offline, or if the tablespace is offline, then the tablespace is not renamed and an error is raised.
Dropping Tablespaces
You can drop a tablespace and its contents (the segments contained in the tablespace) from the database if the tablespace and its contents are no longer required. You must have the DROP TABLESPACE system privilege to drop a tablespace.

Caution: Once a tablespace has been dropped, the data in the tablespace is not recoverable. Therefore, make sure that all data contained in a tablespace to be dropped will not be required in the future. Also, immediately before and after dropping a tablespace from a database, back up the database completely

To drop a tablespace give the following command.

SQL> drop tablespace ica;

This will drop the tablespace only if it is empty. If it is not empty and if you want to drop it anyhow then add the following keyword

SQL>drop tablespace ica including contents;

This will drop the tablespace even if it is not empty. But the datafiles will not be deleted you have to use operating system command to delete the files.

But If  you include datafiles keyword then, the associated datafiles will also be deleted from the disk.

SQL>drop tablespace ica including contents and datafiles;


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
select file_name,tablespace_name,bytes/1024/1024/1024 as  datafile_size,AUTOEXTENSIBLE,status from dba_data_files where AUTOEXTENSIBLE='YES' and 
TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2')order by tablespace_name;


select file_name,tablespace_name,status,bytes/1024/1024/1024 Size_in_GB, AUTOEXTENSIBLE from dba_data_files where TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2') order by tablespace_name;

select a.FILE_NAME,a.TABLESPACE_NAME,a.ONLINE_STATUS,a.AUTOEXTENSIBLE,a.BYTES/1024/1024/1024,b.CREATION_TIME from dba_data_files a, v$datafile b where a.FILE_NAME=b.NAME  and 
TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2') order by  TABLESPACE_NAME ;

select 'alter database datafile '''||file_name||''' AUTOEXTEND OFF;' from dba_data_files where AUTOEXTENSIBLE='YES' and 
TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2')order by tablespace_name;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


ORA-38029: object statistics are locked
***********************************************
details of locked object statistics
--------------------------------------
select * from dba_tab_statistics where stattype_locked is not null and owner not in ('SYS','SYSTEM','DBSNMP') order by owner;

Firstly Unlock table statistics
---------------------------------
select 'exec DBMS_STATS.UNLOCK_TABLE_STATS('''||owner||''','''||table_name||''');' from dba_tab_statistics where stattype_locked is not null and owner not in ('SYS','SYSTEM','DBSNMP') order by owner;

You can now gather table stats and analyze table again
---------------------------------------------------------
select 'exec DBMS_STATS.gather_table_stats('''||owner||''','''||table_name||''');' from dba_tab_statistics where stattype_locked is not null and owner not in ('SYS','SYSTEM','DBSNMP') order by owner;

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

sqlplus "/as sysdba"
spool /db_monitor/change_default_tablespace.log
set time on timing on

set pagesize 9999
set line 9999
col USERNAME for a10
col ACCOUNT_STATUS for a15
col DEFAULT_TABLESPACE for a15
col TEMPORARY_TABLESPACE for a15
col LOCAL_TEMP_TABLESPACE for a15
col LAST_LOGIN for a40
select USERNAME,ACCOUNT_STATUS,LOCK_DATE,DEFAULT_TABLESPACE,TEMPORARY_TABLESPACE,LOCAL_TEMP_TABLESPACE,LAST_LOGIN from dba_users where DEFAULT_TABLESPACE='RETAILDB_DATA';

select 'alter user '||USERNAME||' default tablespace IRAS_DATA;' from dba_users where DEFAULT_TABLESPACE='RETAILDB_DATA';

select USERNAME,ACCOUNT_STATUS,LOCK_DATE,DEFAULT_TABLESPACE,TEMPORARY_TABLESPACE,LOCAL_TEMP_TABLESPACE,LAST_LOGIN from dba_users where DEFAULT_TABLESPACE='IRAS_DATA';


=======================================================================
VI Editing commands
=================================================================
i – Insert at cursor (goes into insert mode)
a – Write after cursor (goes into insert mode)
A – Write at the end of line (goes into insert mode)
ESC – Terminate insert mode
u – Undo last change
U – Undo all changes to the entire line
o – Open a new line (goes into insert mode)
dd – Delete line
3dd – Delete 3 lines.
D – Delete contents of line after the cursor
C – Delete contents of a line after the cursor and insert new text. Press ESC key to end insertion.
dw – Delete word
4dw – Delete 4 words
cw – Change word
x – Delete character at the cursor
r – Replace character
R – Overwrite characters from cursor onward
s – Substitute one character under cursor continue to insert
S – Substitute entire line and begin to insert at the beginning of the line
~ – Change case of individual character

Moving within a file
k – Move cursor up
j – Move cursor down
h – Move cursor left
l – Move cursor right

Saving and Closing the file
Shift+zz – Save the file and quit
:w – Save the file but keep it open
:q – Quit without saving
:wq – Save the file and quit

press Shift + G to move cursor to end of file


=============================================================
ORA-29702: error occurred in Cluster Group Service operation
=============================================================
error occurred in Cluster Group Service operation
This ORA-29702 error is related to the unexpected error occurred while performing a CGS operation.

Verify that the LMON process is still active. Also, check the Oracle LMON trace files for errors.
To solve this error, shutdown database and Relink with RAC OFF option as follows.

$ srvctl stop database -d DB_NAME
OR
SQL> shutdown immediate
 
Once your database is closed, you can start to relink as follows.

$ cd $ORACLE_HOME/rdbms/lib
$ make -f ins_rdbms.mk rac_off
$ make -f ins_rdbms.mk ioracle

If Relink is done successfully,  start database as follows.
$ srvctl start database -d DB_NAME
OR
SQL> startup

==================================================================
select * from dba_tab_partitions where tablespace_name='RETAILDB_DATA' and num_rows<1;
select * from dba_tab_subpartitions where tablespace_name='RETAILDB_DATA' and  num_rows<1;


Query:-  SELECT 'ALTER TABLE ' ||TABLE_OWNER ||'.' ||TABLE_NAME ||' MOVE SUBPARTITION ' ||SUBPARTITION_NAME ||' ONLINE TABLESPACE IRAS_DATA UPDATE INDEXES;
' FROM DBA_TAB_SUBPARTITIONS where TABLESPACE_NAME='RETAILDB_DATA' and table_name like '%ARCHIVE%' and NUM_ROWS >= 1;
 
SELECT SUM(BYTES/1024/1024/1024) FROM DBA_SEGMENTS WHERE OWNER=UPPER('USER_NAME') and ;

Table Size (Check table size in oracle)
================
select segment_name,segment_type, sum(bytes/1024/1024/1024) GB from dba_segments where segment_name='&Your_Table_Name' group by segment_name,segment_type;

Lobs segment details
=======================
select * from dba_lobs where table_name = 'TBL_DU_OTP_DETAILS';

select segment_name,segment_type,sum(bytes/1024/1024/1024) from dba_segments where segment_name in ('TBL_DU_OTP_DETAILS',
'SYS_LOB0000885315C00019$$',
'SYS_LOB0000885315C00003$$',
'SYS_LOB0000885315C00004$$',
'SYS_LOB0000885315C00005$$'
) group by segment_name,segment_type;




RMAN> RESTORE DATABASE PREVIEW;
RMAN> RESTORE DATABASE PREVIEW SUMMARY;
Review oracle server to mumtaz== RetailDB



RMAN> spool log to 'db_monitor/validate_18092022.log'

run {
allocate channel t1 device type 'SBT_TAPE';
allocate channel t2 device type 'SBT_TAPE';
allocate channel t3 device type 'SBT_TAPE';
allocate channel t4 device type 'SBT_TAPE';
allocate channel t5 device type 'SBT_TAPE';
allocate channel t6 device type 'SBT_TAPE';
allocate channel t7 device type 'SBT_TAPE';
allocate channel t8 device type 'SBT_TAPE';
allocate channel t9 device type 'SBT_TAPE';
allocate channel t10 device type 'SBT_TAPE';
allocate channel t11 device type 'SBT_TAPE';
allocate channel t12 device type 'SBT_TAPE';
allocate channel t13 device type 'SBT_TAPE';
allocate channel t14 device type 'SBT_TAPE';
allocate channel t15 device type 'SBT_TAPE';
allocate channel t16 device type 'SBT_TAPE';
send 'NSR_ENV=(NSR_SERVER=MUDPVTLBKP01.DS.INDIANOIL.IN,NSR_CLIENT=mudcporaind01-vip,NSR_DATA_VOLUME_POOL=OraBkp)';
set until time "to_date('18-09-2022 19:45:00','mm/dd/yyyy hh24:mi:ss')" 
RESTORE DATABASE PREVIEW;
release channel t1;
release channel t2;
release channel t3;
release channel t4;
release channel t5;
release channel t6;
release channel t7;
release channel t8;
release channel t9;
release channel t10;
release channel t11;
release channel t12;
release channel t13;
release channel t14;
release channel t15;
release channel t16;
}



High_cost Query
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

column program format A25
column machine format A10
column module format A25
column user_id format 9999999
column count format 99999
SELECT * FROM (
SELECT /*+ PARALLEL */
        count(*) AS count,
        a.user_id, a.program, a.module, a.machine, a.sql_id, c.cost
        ,ROW_NUMBER() OVER (PARTITION BY a.sql_id ORDER BY c.cost DESC) rank 
 FROM SYS.DBA_HIST_ACTIVE_SESS_HISTORY a, gv$sql_plan c
WHERE a.sample_time > TO_DATE('06-oct-2022 10:00:00','DD-MON-YYYY HH24:MI:SS')
AND a.sample_time < TO_DATE('06-oct-2022 18:00:00','DD-MON-YYYY HH24:MI:SS')
AND a.sql_id=c.sql_id
AND C.COST IS NOT NULL
GROUP BY a.user_id, a.program, a.module, a.machine, a.sql_id,  c.cost
ORDER BY a.sql_id,C.COST desc
)  where rank = 1 order by cost desc
/


Kafka Purging
============================================================================================================
Daily
---------------------------------------------
WITH date_partition AS (
    SELECT  TABLE_OWNER,table_name,partition_name,
            TO_DATE(
                substr(
                    extractvalue(dbms_xmlgen.getxmltype(
                        'select high_value FROM dba_TAB_PARTITIONS WHERE table_name = ''' || t.table_name || ''' and PARTITION_NAME = ''' || t.partition_name || ''''
                    ), '//text()')
                , 12, 10),
            'YYYY-MM-DD') AS high_value_t
    FROM dba_tab_partitions t
    WHERE TABLE_NAME in (select TABLE_NAME from sys.daily_table_purge)
) 
SELECT table_name,partition_name,to_date(high_value_t, 'DD-MON-YY'), 'ALTER TABLE ' || table_owner || '.' || table_name || ' DROP PARTITION ' || partition_name || ' UPDATE INDEXES;'
FROM date_partition
WHERE to_date(high_value_t, 'DD-MON-YY') <  to_date('30-AUG-22', 'DD-MON-YY') order by TABLE_NAME,high_value_t desc;

Monthly
--------------------------------------------
WITH date_partition AS (
    SELECT  TABLE_OWNER,table_name,partition_name,
            TO_DATE(
                substr(
                    extractvalue(dbms_xmlgen.getxmltype(
                        'select high_value FROM dba_TAB_PARTITIONS WHERE table_name = ''' || t.table_name || ''' and PARTITION_NAME = ''' || t.partition_name || ''''
                    ), '//text()')
                , 12, 10),
            'YYYY-MM-DD') AS high_value_t
    FROM dba_tab_partitions t
    WHERE TABLE_NAME in (select TABLE_NAME from sys.monthly_table_purge)
) 
SELECT table_name,partition_name,to_date(high_value_t, 'DD-MON-YY'), 'ALTER TABLE ' || table_owner || '.' || table_name || ' DROP PARTITION ' || partition_name || ' UPDATE INDEXES;'
FROM date_partition
WHERE to_date(high_value_t, 'DD-MON-YY') <  to_date('30-AUG-22', 'DD-MON-YY') order by TABLE_NAME,high_value_t desc;

=====================================================================================================================

SCHEDULED JOB Status
-------------------------------------------------------
SELECT owner, job_name,status,LOG_DATE, ERROR#, ( EXTRACT (SECOND FROM run_duration) /60 + EXTRACT (MINUTE FROM run_duration) + EXTRACT (HOUR FROM run_duration) * 60 + EXTRACT (DAY FROM run_duration) * 60 * 24) MINUTES,ADDITIONAL_INFO 
FROM dba_scheduler_job_run_details
WHERE LOG_DATE > SYSDATE - 7 AND status != 'SUCCEEDED' ORDER BY 1 ASC, 4 DESC;

SELECT OWNER, JOB_NAME, LAST_START_DATE, STATE
FROM DBA_SCHEDULER_JOBS
WHERE LAST_START_DATE > SYSDATE - 1 AND STATE <> 'SCHEDULED';



Query Finding the Index Rebuild:-


select OWNER,SEGMENT_NAME,SEGMENT_TYPE,TABLESPACE_NAME,BYTES/1024/1024 "MB" from dba_segments where  tablespace_name='SYSAUX' ORDER BY MB DESC;

Fast-Start Failover: how to set from  enabled to disabled

DGMGRL> DISABLE FAST_START FAILOVER;


 
 
 Patching link:-
 
 Please download the latest OPatch version from My Oracle Support (MOS) using the next reference:
Patch 6880880

Or using the next URL:

https://updates.oracle.com/download/6880880.html

https://support.oracle.com/knowledge/Oracle%20Cloud/2521164_1.html


Restoration status in TB:-
select SID,OPERATION,STATUS,MBYTES_PROCESSED/1024/1024 as TB_PROCESSED from v$rman_status where STATUS='RUNNING';
select SID,OPERATION,STATUS,MBYTES_PROCESSED/1024/1024 as GB_PROCESSED from v$rman_status where STATUS='RUNNING';
select SID,OPERATION,STATUS,MBYTES_PROCESSED/1024/1024 as MB_PROCESSED from v$rman_status where STATUS='RUNNING';

Rahul sir share link.

\\10.146.76.86\sqldeveloper

mrp status with delta
============================================================================================================================================
select a.thread#, applied, notappld, notappld-applied delta from
(select thread#, max(sequence#) applied  from gv$archived_log where applied='YES' and resetlogs_change#=(select resetlogs_change#
from  v$database)
group by thread#) A,(select thread#, max(sequence#) notappld
from gv$archived_log where resetlogs_change#=(select resetlogs_change# from  v$database) group by thread#) B
where a.thread# = b.thread#;

While setting of DR:
============================================================================================================================================================================
If database is not in SYNC:
=============================================================================================================
edit database indsoftdb set state=APPLY-OFF;  
rman target sys
RMAN> recover database from service indsoftdbnew noredo using compressed backupset;

To refresh the control file:
============================================================================================================
RMAN> shutdown immediate  
RMAN> startup nomount  
RMAN> restore standby controlfile from service INDSOFTDBNEW;  

how to read control file ?
------------------------------------------------
SQL> ALTER DATABASE BACKUP CONTROLFILE TO TRACE AS '/tmp/controlfile.txt';

To know which query was running ON BACKGROUND:

select inst_id, program, module, SQL_ID, machine from gv$session where type!=' BACKGROUND' and status='ACTIVE' and sql_id is not null; 

-- check the sql hashes 
SELECT sql_id
, sql_text
, hash_value
FROM v$sql
WHERE 1=1
AND lower(sql_text) LIKE '%select%';

Table data restore by using timestamp:-
==============================================================================================================================================

SELECT * FROM MISR.MISR_ETHANOL_MAIL_LOGS AS OF TIMESTAMP 
   TO_TIMESTAMP('2022-11-26 16:00:00', 'YYYY-MM-DD HH24:MI:SS');


Create table MISR.MISR_ETHANOL_MAIL_LOGS_Temp as  Select * from MISR.MISR_ETHANOL_MAIL_LOGS AS OF TIMESTAMP 
   TO_TIMESTAMP('2022-11-26 04:00:00', 'YYYY-MM-DD HH:MI:SS');
   
  Create table MISR.MISR_ETHANOL_MAIL_LOGS_Temp2 as  Select * from MISR.MISR_ETHANOL_MAIL_LOGS AS OF TIMESTAMP 
   TO_TIMESTAMP('2022-11-26 16:00:00', 'YYYY-MM-DD HH24:MI:SS');
   
   
   
AWR Snapshot interval retention:
https://dbaclass.com/article/modify-awr-snapshot-interval-setting/